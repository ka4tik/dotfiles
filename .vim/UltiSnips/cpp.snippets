snippet randombst "Random bst" !b
struct RandomBST{

    struct Node {
        int key; int val;
        Node *left,*right;
        int N;
        Node(int k, int v) {
            key=k;
            val=v; 
            left = right = NULL;
            N=1;
        }
    };

    double randdouble()
    {
        return double(rand())/double(RAND_MAX);
    }
    Node *root;

    RandomBST() {root = NULL;}


    Node*  rotateLeft (Node *lt)
    {  Node *rt = lt->right, *q = rt->left;
        lt->N=1+size(lt->left)+size(lt->right->left);
        lt->right->N=1+size(lt->right->right)+lt->N;
        rt->left = lt;
        lt->right= q;
        return rt;      
    }

    Node* rotateRight(Node *rt)
    {  Node  *lt = rt->left, *q = lt->right;
        rt->N=1+size(q)+size(rt->right);
        rt->left->N=1+size(lt->left)+rt->N;
        lt->right= rt;
        rt->left = q;
        return lt;       
    }
    Node* insertRoot(Node* tree, int key, int val) {
        if (tree == NULL) return new Node(key, val);
        if (tree->key==key) {
            tree->key = key; tree->val = val;
        }
        else if(key < tree->key) {
            tree->left = insertRoot(tree->left, key, val);
            tree = rotateRight(tree);
        }
        else {
            tree->right = insertRoot(tree->right, key, val); 
            tree = rotateLeft(tree);
        }
        return tree;
    }

    Node* insertRandom(Node *tree, int key, int val) 
    {
        if (tree == NULL)  {
            return new Node(key,val);
        }
        if (randdouble()*(tree->N+1) < 1.0) // with probability 1/(N+1)
            return insertRoot(tree, key, val);
        if (tree->key==key) {
            tree->key = key; tree->val = val;
        } else if (key<tree->key) {
            tree->left = insertRandom(tree->left, key, val);
            tree->N = 1 + tree->left->N + size(tree->right);
        } else {
            tree->right = insertRandom(tree->right, key, val); 
            tree->N = 1 + size(tree->left) + tree->right->N;
        }
        return tree;
    }
    int size(Node *tree) {return (tree == NULL) ? 0 : tree->N;}
    int size() {return (root == NULL) ? 0 : root->N;}

    void insert(int key, int val) {
        root = insertRandom(root, key, val);
    }

    int search(int key) 
    {
        return searchAux(root, key);
    }

    int searchAux(Node *tree, int key) 
    {
        if (tree == NULL)
            return 0;
        if (tree->key==key)
            return tree->val;
        return (key < tree->key) ? searchAux(tree->left, key) : searchAux(tree->right, key);
    }

    void inorder(Node *tree)
    {
        if(tree==NULL) return;
        inorder(tree->left);
        cout<<tree->key<<" ";
        inorder(tree->right);
    }
    int kth_smallest(Node *tree,int k)
    {
        if(tree==NULL)
            return INT_MIN;
        if(k==size(tree->left)+1)
            return tree->key;
        if(size(tree->left)>=k)
            return kth_smallest(tree->left,k);

        else
            return kth_smallest(tree->right,k-size(tree->left)-1);
    }
    int kth_smallest(int k)
    {
        return kth_smallest(root,k);
    }
    Node* join(Node* X, Node *Y) {
        if(X == NULL) return Y;
        if(Y == NULL) return X;
        if(randdouble()*(X->N + Y->N) < X->N) { // flip a weighted coin
            X->right = join(X->right, Y);
            X->N = 1 + size(X->left) + size(X->right);
            return X;
        } else {
            Y->left = join(X, Y->left);
            Y->N = 1 + size(Y->left) + size(Y->right);
            return Y;
        }
    }
    int remove(int key) {
        root=searchThenRemove(root,key);
    }
    Node* searchThenRemove(Node *tree, int key) {
        if (tree == NULL)
            return NULL;
        if (tree->key==key)
        {
            Node *left=tree->left;
            Node *right=tree->right;
            delete tree;
            return join(left,right);
        }
        if(key < tree->key) {
            tree->left=searchThenRemove(tree->left, key);
            tree->N=size(tree->left)+size(tree->right)+1;
            return tree;
        }
        else
        {
            tree->right=searchThenRemove(tree->right, key);
            tree->N=size(tree->left)+size(tree->right)+1;
            return tree;
        }
    }
    int count_less_than(Node *tree,int key)
    {
        if(tree==NULL)
            return 0;
        if(tree->key>=key)
        {
            return count_less_than(tree->left,key);
        }
        else if(tree->key<key)
        {
            return size(tree->left)+(tree->key<key)+count_less_than(tree->right,key);
        }
        else return 0;
    }
    int count_less_than(int key)
    {
        return count_less_than(root,key);
    }

};
endsnippet
snippet heap "Heap Sort" !b
void heapify(vector<int> &v,int i,int n)
{
    int left=2*i+1;
    int right=2*i+2;
    int largest=i;
    if(left<n && v[left]>v[largest])
        largest=left;
    if(right<n && v[right]>v[largest])
        largest=right;

    if(largest!=i)
    {
        swap(v[i],v[largest]);
        heapify(v,largest,n);
    }
}
void build_heap(vector<int> &v)
{
    for(int i=v.size()/2-1;i>=0;i--)
        heapify(v,i,v.size());
}
void heap_sort(vector<int> &v)
{
    build_heap(v);
    int n=v.size();
    for(int i=v.size()-1;i>=0;i--)
    {
        swap(v[0],v[n-1]);n--;
        heapify(v,0,n);
    }
}
endsnippet
snippet kmp "Kmp Algorithm for string matching" !b
vector<int> kmp_table(string pattern)
{
    int pos=1;
    int candidate=0;
    vector<int> T(pattern.length());
    T[0]=0;
    while(pos<pattern.length())
        if(pattern[pos]==pattern[candidate])
            candidate++,T[pos]=candidate,pos++;
        else if(candidate>0)
            candidate=T[candidate-1];
        else  
            T[pos]=0,pos++;
    return T;
}
vector<int> kmp_search(string pattern,string str)
{
    vector<int> T=kmp_table(pattern);
    int m=0;
    int i=0;
    vector<int> matches;
    while(m+i<str.length())
    {
        if(str[m+i]==pattern[i])
        {
            if(i==pattern.length()-1)
            {
                matches.push_back(m);
                if(i>0)
                    m=m+i-T[i-1],i=T[i-1];
                else
                    m++,i=0;
            }
            else
                i++;
        }
        else if(i>0)
            m=m+i-T[i-1],i=T[i-1];
        else
            m++,i=0;
    }
    return matches;
}
endsnippet
snippet normalize_array "Normalizes array values" !b
vector<int> normalize_array(vector<int> v)
{
    clock_t start=clock();
    vector<int> vc=v;
    sort(vc.begin(),vc.end());
    vc.erase(unique(vc.begin(),vc.end()),vc.end());
    map<int,int> m;
    for(int i=0;i<vc.size();i++)
        m[vc[i]]=i+1;
    for(int i=0;i<v.size();i++)
        v[i]=m[v[i]];
    return v;
}
endsnippet
snippet find_bounds "Finds left most and right most indexes in a sorted array" !b
pair<int,int> find_bounds(vector<int> &A, int target) 
{
    int n=A.size();
    int lo=0;
    int hi=n-1;
    while(lo<hi)//finds left most bound
    {
        int mid=lo+(hi-lo)/2;
        if(A[mid]<target)
            lo=mid+1;
        else
            hi=mid;
    }
    if(A[lo]!=target)
    {
        return pair<int,int>(-1,-1);
    }
    pair<int,int> ret;
    ret.first=lo;
    lo=0;hi=n-1;
    while(lo<hi)// finds rightmost bound
    {
        int mid=hi-(hi-lo)/2;
        if(A[mid]<=target)
            lo=mid;
        else
            hi=mid-1;
    }
    ret.second=lo;
    return ret;
}
endsnippet
snippet hungarian "Hungarian Algorithm for maximum cost matching" !b
#define INF (int)1e9
const int maxNode =100;
int cost[maxNode][maxNode],X[maxNode],Y[maxNode];

void hungarian(int nx, int ny)
{
    int Lx[maxNode], Ly[maxNode], Q[maxNode], prev[maxNode];

    memset(X, -1, sizeof X); memset(Y, -1, sizeof Y);
    memset(Lx, 0, sizeof Lx); memset(Ly, 0, sizeof Ly);

    for(int i = 0; i < nx; i++)
        for(int j = 0; j < ny; j++)
            Lx[i] = max( Lx[i], cost[i][j]);

    for(int i = 0;i < nx; )
    {
        memset( prev, -1, sizeof prev);
        int head = 0, tail = 0;
        for(Q[tail++] = i; head < tail && X[i] < 0; head ++)
        {
            int u = Q[head];
            for(int v = 0; v < ny && X[i] < 0; v++)
            {
                if( prev[v] >= 0 || Lx[u] + Ly[v] > cost[u][v] ) continue;
                if( Y[v] >=  0)
                    prev[v] = u,  Q[tail++] = Y[v];
                else
                {
                    prev[v] = u;
                    for(int at = v; at >=0; )
                    {
                        u = Y[at] = prev[at];
                        //swap X[u] , at
                        int a = X[u];
                        X[u] = at;
                        at = a;
                    }
                }
            }

        }

        if( X[i] >=0) i ++;
        else
        {
            int alpha = INF;
            for(int head = 0; head < tail; head++)
            {
                int u = Q[head];
                for(int v = 0; v < ny; v++)
                    if( prev[v] == -1)
                        alpha = min ( alpha, Lx[u] + Ly[v] - cost[u][v] );
            }

            for(int head = 0; head < tail; head ++)
                Lx[Q[head]] -= alpha;

            for(int v = 0; v < ny; v++)
                if( prev[v] >= 0 )
                    Ly[v] += alpha;
        }
    }

}
endsnippet
snippet combination "Combinations gernerator" !b
void Comb(vector<int> a,vector<int> data,int start,int end,int index,int r)
{
    if(index==r)
    {
        for(int i=0;i<r;i++)
            printf("%d",data[i]);
        printf("\n");
        return ;
    }

    for(int i=start;i<=end&&end-i+1>=r-index;i++)
    {
        data[index]=a[i];
        Comb(a,data,i+1,end,index+1,r);
    }
}
void combination(vector<int> a ,int n,int r)
{
    vector<int> data(r);
    Comb(a,data,0,n-1,0,r);
}
endsnippet
snippet manchester "Manchester's Algorithm for longest palindromic substring " !b
int p[N+1],mx=0,id=0;
// length of longest palindrome centred at i is 2 * p[i]-1.
for (int i=1;i<=N;i++) 
{
	p[i]=mx>i?min(p[2*id-i],mx-i):1;
	while(str[i+p[i]]==str[i-p[i]]) 
		p[i]++;
	if(i+p[i]>mx) 
	{
		mx=i+p[i];
		id=i;
	}
}
endsnippet
snippet histogram "Largest rectangle in histogram and Maximum submatrix of ones O(N) and O(N^2)" !b
struct iii{
    int a;
    int b;
    int c;
    iii(int _a,int _b,int _c)
    {
        a=_a;
        b=_b;
        c=_c;

    }
};
struct iiiii{
    int a;
    int b;
    int c;
    int d;
    int e;
    iiiii(int _a,int _b,int _c,int _d,int _e)
    {
        a=_a;
        b=_b;
        c=_c;
        d=_d;
        e=_e;

    }
};
int N;
int Grid[MAXN][MAXN];
iii getLargestRectange(int a[])
{
    stack<int> heights,indexes;
    int largestAreaSize=0;
    int startx;int endx;
    for(int i=0;i<N;i++)
    {
        if(heights.empty()==1||a[i]>heights.top())
        {
            heights.push(a[i]);
            indexes.push(i);
        }
        else if(a[i]<heights.top())
        {
            int lastindex=0;
            while(!heights.empty()&&a[i]<heights.top())
            {
                lastindex=indexes.top();indexes.pop();
                int tempAreaSize=heights.top()*(i-lastindex);heights.pop();
                if(largestAreaSize<tempAreaSize)
                {
                    startx=lastindex;
                    endx=i-1;
                    largestAreaSize=tempAreaSize;
                }

            }

            heights.push(a[i]);
            indexes.push(lastindex);

        }
    }
    while(!heights.empty())
    {
        int lastindex=indexes.top();
        int tempAreaSize=heights.top()*(N-indexes.top());heights.pop();indexes.pop();
        if(largestAreaSize<tempAreaSize)
        {
            startx=lastindex;
            endx=N-1;
            largestAreaSize=tempAreaSize;
        }
    }
    return iii(largestAreaSize,startx,endx);	
}

iiiii getMaximumRectangleofONES()
{

    int maxarea=0;
    int x1,y1,x2,y2;

    int a[N];
    for(int i=0;i<N;i++)a[i]=0;
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<N;j++)
        {
            if(Grid[i][j]==1)
                a[j]=a[j]+1;
            else
                a[j]=0;
        }
        iii temp = getLargestRectange(a);
        int A=temp.a;
        int r2=i;
        int c1=temp.b;
        int c2=temp.c;
        int r1=r2-(A/(c2-c1+1))+1;
        if(A>maxarea)
        {
            maxarea=A;
            x1=r1;
            y1=c1;
            x2=r2;
            y2=c2;		
        }
    }
    return iiiii(maxarea,x1,y1,x2,y2);
}
endsnippet

snippet rankgauss "Rank of a matrix using gauss jordon" !b
int rank(int M, int N, vector< vector<int> > a, vector<int> b, int p) {
    // M equations, N variables, modulo p
    int ans = 0;
     
    vector<bool> used(M,0);
     
    // Using Gauss-Jordan in [ A : b ] to make it in row-echellon form.
    // So that we can find the rank. We also need to make sure that the
    // rank of [ A ] is equal to the rank of [A : b], else there are
    // no solutions
    for (int j=0; j<N; j++){
        int i = 0;
        while ( (i < M) && (used[i] || (a[i][j] == 0) ) ) {
            i++;
        }
        if(i == M) continue;
        ans++;
        used[i] = true;
        for (int k=0; k<M; k++) if(!used[k]){
            // Find a value of coef equal to (-a[k][j] / a[i][j]);
            // we can just try 0,1,..,p-1 until we find one.
            int coef = 0;
            while ( (a[i][j] * coef + a[k][j]) % p != 0) {
                coef++;
            }
            for (int l=0; l<N; l++) {
                 a[k][l] = (a[k][l] + a[i][l] * coef) % p;
            }
            b[k] = (b[k] + b[i] * coef) % p;
        }
    }
     
    // If rank of [A] is not equal to the rank of [A : b]
    for (int i=0; i<M; i++) {
         if(!used[i] && b[i] != 0) {
              return -1;
         }
    }
          
    return ans;
}
endsnippet
snippet sumv "get sum of elements of a vector" !b
int sumv=accumulate(v.begin(),v.end(),0);
endsnippet
snippet sv "get a vector input" !b
for(int i=0;i<v.size();i++) s(v[i]);
endsnippet
snippet kadane "Kadane Algorithm" !b
vector<int> kadane(vector<int> v)
{
    int N=v.size();
    int allnegative=1;
    int max_ending_here=0;
    int max_so_far=0;
    vector<int> maxs(N);
    int maxx=INT_MIN;
 
    for(int i=0;i<N;i++)
    {
        if(v[i]>=0)
            allnegative=0;
        maxx=max(v[i],maxx);
        max_ending_here=max(v[i],max(0,max_ending_here+v[i]));
        max_so_far=max(max_ending_here,max_so_far);
        if(allnegative)
        {
            maxs[i]=maxx;
        }
        else
            maxs[i]=max_so_far;
    }
    return maxs;
}
endsnippet
snippet pie "Pi and e constants" !b
const long double e=M_E;
const long double pi=M_PI;
const long double e=2.71828182845904523536;
const long double pi=3.14159265358979323;
endsnippet
snippet logfactorial "Sterling Approximation of Factorial" !b
const double e=m_e;
const double pi=m_pi;
double log_basea_factorial(int n,int a)
{
    double ans=n*(log(n)-log(e))/log(a)+0.5*(log(2*pi)+log(n))/log(a);
    return ans;
}
endsnippet
snippet matrixexpo "Description" !b
#define mod 1000000007
typedef vector<int> vi;
typedef vector< vector<int> > vvi;
vvi matrixUnit(int n)
{
    vvi res(n,vi(n,0));
    for(int i=0;i<n;i++)
        res[i][i]=1;
    return res;
}
vvi matrixAdd(vvi &a,vvi &b)
{
    int n=a.size();
    int m=a[0].size();
    vvi res(n,vi(m));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            res[i][j]=a[i][j]+b[i][j];
            if(res[i][j]>=mod)
                res[i][j]%=mod;
        }
    }
    return res;
}
vvi matrixMul(const vvi &a, const vvi &b) 
{
    int n =a.size();
    int m =a[0].size();
    int k =b[0].size();
    vvi res(n,vi(k));
    for (int i=0;i<n;i++)
        for (int j=0;j<k;j++)
            for (int p=0;p<m;p++)
                res[i][j]=(res[i][j]+(long long)a[i][p]*b[p][j])%mod;

    return res;
}
vvi matrixPow(vvi a,int p)
{
    int n=a.size();
    if(p==0)
        return matrixUnit(a.size());
    if((p&1))
        return matrixMul(a,matrixPow(a,p-1));
    else
        return matrixPow(matrixMul(a,a),p/2);
}
void matrixPrint(vvi a)
{
    for(int i=0;i<a.size();i++)
    {
        for(int j=0;j<a[i].size();j++)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
}
int fibo(int n)
{
    vvi T=matrixUnit(2);
    T[0][0]=1;
    T[0][1]=1;
    T[1][0]=1;
    T[1][1]=0;
    T=matrixPow(T,n);
    return T[0][0];
}
endsnippet
snippet bpm "Bipartite Matching" !b
vector<int> visit;
vector<int> match;
int edge[MAXN][MAXN];
int n,m;
int dfs(int u)
{
    if(visit[u]) return false;
    visit[u]=1;
    for(int i=0;i<n;i++)
    {
        if(!edge[u][i]) continue;
        if(match[i]==-1||dfs(match[i]))
        {
            match[i]=u;
            return true;
        }
    }
    return false;
}
int bmp()
{
    int matched=0;
    match.assign(m,-1);

    for(int i=0;i<n;i++)
    {
        visit.assign(n,0);
        if(dfs(i))
            matched++;
    }
    return matched;

}
endsnippet
snippet mincostmatch "Hungerian Algorithm for mincost matching in Bipartite Graph O(N^2*M)" !b
#define INF INT_MAX
int n,m;
vector< vector<int> > a;
vector<int> ans;
//if perfect maching is required add infinity to missing edges otherwise add 0
int min_cost_match(){

    vector<int> u(n+1),v(m+1),p(m+1),way(m+1);

    for(int i=1;i<=n;++i) 
    {
        p[0] = i;
        int j0 = 0;
        vector<int> minv (m+1, INF);
        vector<char> used (m+1, false);
        do {
            used[j0] = true;
            int i0 = p[j0],  delta = INF,  j1;
            for (int j=1; j<=m; ++j)
                if (!used[j]) {
                    int cur = a[i0][j]-u[i0]-v[j];
                    if (cur < minv[j])
                        minv[j] = cur,  way[j] = j0;
                    if (minv[j] < delta)
                        delta = minv[j],  j1 = j;
                }
            for (int j=0; j<=m; ++j)
                if (used[j])
                    u[p[j]] += delta,  v[j] -= delta;
                else
                    minv[j] -= delta;
            j0 = j1;
        }
        while (p[j0] != 0);
        do {
            int j1 = way[j0];
            p[j0] = p[j1];
            j0 = j1;
        }
        while (j0);
    }
    ans.resize(n+1);
    for(int i=1;i<=m;i++)
    {
        ans[p[i]]=i;
    }
    //for(int i=1;i<=n;i++)
    //{
        //cout<<ans[i]<<" ";
    //}
    //cout<<endl;

    int cost=-v[0];
    return cost; 
}
endsnippet
snippet ss "String scanf" !b
scanf("%s",str);
endsnippet
snippet suffixarray "Suffix Array" !b
char str[MAXN];
const int alphabet=256;
int log_n;
int n;
vector< vector<int> > cns;
vector< int> sa;
int compare (int i, int j, int l) //compare to strings of len l in contant time
{
    int k=0;
    while((1<<k)<l)
        k++;
    if((1<<k)>l) k--;

    pair<int,int> a = make_pair (cns[k][i], cns[k][i+l-(1<<k)]);
    pair<int,int> b = make_pair (cns[k][j], cns[k][j+l-(1<<k)]);
    return a == b ? 0 : a < b ? -1 : 1;
}
int lcp(int i,int j) //longest common prefix of substrings at index i and j
{
    int len=0;
    int oi=i,oj=j;
    for(int k=cns.size()-1;k>=0;k--)
    {
        if(cns[k][i]==cns[k][j])
        {
            len+=(1<<k);
            i+=(1<<k);
            j+=(1<<k);
        }
    }
    return (min(min(n-oi,n-oj),len));

}
void suffix()
{

    cns.clear();
    vector<int> cnt(max(alphabet,n),0);
    vector<int> p(n);
    vector<int> c(n);

    for (int i=0; i<n; ++i)
        ++cnt[str[i]];

    for (int i=1; i<alphabet; ++i)
        cnt[i] += cnt[i-1];
    for (int i=0; i<n; ++i)
        p[--cnt[str[i]]] = i;

    c[p[0]] = 0;

    int classes = 1;
    for (int i=1; i<n; ++i) {
        if (str[p[i]] != str[p[i-1]])  ++classes;
        c[p[i]] = classes-1;
    }
    cns.push_back(c);
    vector<int> pn(n);
    vector<int> cn(n);
    for (int h=0; (1<<h)<n; ++h) {
        for (int i=0; i<n; ++i) {
            pn[i] = p[i] - (1<<h);
            if (pn[i] < 0)  pn[i] += n;
        }
        for(int i=0;i<classes;i++) cnt[i]=0;

        for (int i=0; i<n; ++i)
            ++cnt[c[pn[i]]];
        for (int i=1; i<classes; ++i)
            cnt[i] += cnt[i-1];
        for (int i=n-1; i>=0; --i)
            p[--cnt[c[pn[i]]]] = pn[i];
        cn[p[0]] = 0;
        classes = 1;
        for (int i=1; i<n; ++i) {
            int mid1 = (p[i] + (1<<h)) % n,  mid2 = (p[i-1] + (1<<h)) % n;
            if (c[p[i]] != c[p[i-1]] || c[mid1] != c[mid2])
                ++classes;
            cn[p[i]] = classes-1;
        }
        c=cn;
        cns.push_back(c);
    }
    sa=p;
    for(int i=0;i<sa.size();i++)
    {
		cout<<sa[i]<<" ";
    }
    cout<<endl;
}
endsnippet

snippet fordadj "Ford Fukerson for large graphs" !b
struct edge {
    int a, b, cap, flow;
};
vector<edge> e;
vector<int> g[MAXN];
int visit[MAXN];
int n;
int s,t;
int limit=INT_MAX;
void add_edge (int a, int b, int cap) {
    edge e1 = { a, b, cap, 0 };
    edge e2 = { b, a, 0, 0 };
    g[a].push_back ((int) e.size());
    e.push_back (e1);
    g[b].push_back ((int) e.size());
    e.push_back (e2);
}
int dfs(int u,int t,int c)
{
    if(visit[u])
        return false;
    visit[u]=1;
    if(u==t) return true;
    for (int i=0; i<g[u].size();i++) {
        int id = g[u][i],
            to = e[id].b;
        if((e[id].cap-e[id].flow)>=c&&dfs(to,t,c))
        {
            e[id].flow+=c;
            e[id^1].flow-=c;
            return true;
        }
    }
    return false;
}
int maxflow()
{
    int flow=0;
    int c=limit;
    while(c)
    {
        for(int i=0;i<n;i++) visit[i]=0;
        int f=dfs(s,t,c);
        if(!f)
            c/=2;
        else
            flow+=c;
        if(flow>=limit)
            return flow=limit;
    }
    return flow;
}
endsnippet

snippet fordmatrix "Ford Fukkerson Maxflow using Capicty Matrix" !b
#define INF INT_MAX 
int cap[MAXN][MAXN];
int visit[MAXN];
int n;
int s,t;
int limit=INT_MAX;
int dfs(int u,int t,int c)
{
    if(visit[u])
        return false;
    visit[u]=1;
    if(u==t) return true;
    for(int i=0;i<n;i++)
    {
        if(cap[u][i]>=c&&dfs(i,t,c))
        {
            cap[u][i]-=c;
            cap[i][u]+=c;
            return true;
        }
    }
    return false;
}
int maxflow()
{
    int flow=0;
    int c=limit;
    while(c)
    {
        for(int i=0;i<n;i++) visit[i]=0;
        int f=dfs(s,t,c);
        if(!f)
            c/=2;
        else
            flow+=c;
        if(flow>=limit)
            return flow=limit;
    }
    return flow;
}
endsnippet

snippet dinic "Description" !b
const int INF = INT_MAX;
int n, c[MAXN][MAXN], f[MAXN][MAXN], s, t, d[MAXN], ptr[MAXN], q[MAXN];
bool bfs() {
    int qh=0, qt=0;
    q[qt++] = s;
    memset (d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt) {
        int v = q[qh++];
        for (int to=0; to<n; ++to)
            if (d[to] == -1 && f[v][to] < c[v][to]) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
    }
    return d[t] != -1;
}

int dfs (int v, int flow) {
    if (!flow)  return 0;
    if (v == t)  return flow;
    for (int & to=ptr[v]; to<n; ++to) {
        if (d[to] != d[v] + 1)  continue;
        int pushed = dfs (to, min (flow, c[v][to] - f[v][to]));
        if (pushed) {
            f[v][to] += pushed;
            f[to][v] -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())  break;
        memset (ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs (s, INF))
            flow += pushed;
    }
    return flow;
}

endsnippet
snippet egcd "Extended GCD" !b
int egcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    
    int x1,y1;
    int d=egcd(b,a%b,x1,y1);
    y=x1;
    x=y1-(b/a)*x1;
    return d;
}
endsnippet
snippet phifast "phifast" !b
int totient[MAXN];
vector<bool> mark(MAXN>>1);
int lf[MAXN];
int phi(int n)
{
    int ret=n;
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0) ret-=ret/i;
        while(n%i==0)
            n/=i;
    }
    if(n>1)
        ret-=ret/n;
    return ret;
}
bool isprime(int n)
{
    if(n<2) return 0;
    if(n==2) return 1;
    if(!(n&1)) return 0;
    else
        return !mark[n>>1];
}
int phifast(int n)
{
    if(totient[n]) return totient[n];
    if(n<=1) return 1;

    if(isprime(n))
        return totient[n]=n-1;

    if(!(n&1))
    {
        int m=n>>1;
        if((m&1))
            return totient[n]=phifast(m);
        else
            return totient[n]=phifast(m)<<1;
    }

    int o=n/lf[n];
    int m=lf[n];
    int g=__gcd(m,o);

    if(g==1)
        return totient[n]=phifast(m)*phifast(o);
    else
        return totient[n]=phifast(m)*phifast(o)*g/phifast(g);

}
void sieve()
{
    int i;
    for(i=3;i*i<MAXN;i+=2)
    {
        if(!mark[i>>1])
        {
            for(int j=i*i;j<MAXN;j+=2*i)
            {
                mark[j>>1]=1;	
                lf[j]=i;

            }
        }
    
    }
}

endsnippet
snippet isprime "Description" !b
bool isprime(long long n) {
  if (n<=1)
    return false;

  for (long long i=2;i*i<=n;i++)
    if (n%i==0)
      return false;

  return true;
}
endsnippet
snippet phi "Single Totinet" !b
int phi(int n)
{
    int ret=n;
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0) ret-=ret/i;
        while(n%i==0)
            n/=i;
    }
    if(n>1)
        ret-=ret/n;
    return ret;
}
endsnippet
snippet rmq "Range Min Query" !b
#define MAXN 111111
int tree[4*MAXN];
int lazy[4*MAXN];
vector<int> v;
int N;
void build(int node,int start,int end)
{
    if(start>end)
        return ;
    if(start==end)
    {
        tree[node]=v[start-1];
        return ; 
    }

    int mid=(start+end)>>1;
    build(2*node,start,mid);
    build(2*node+1,mid+1,end);

    tree[node]=min(tree[2*node],tree[2*node+1]);
}
void update(int node,int start,int end,int index,int value)
{
    if(start>end)
        return ;
    if(start==end)
    {
        tree[node]=value;
        return ;
    }
    int mid=(start+end)>>1;
    if(index<=mid)
        update(2*node,start,mid,index,value);
    else
        update(2*node+1,mid+1,end,index,value);

    tree[node]=min(tree[2*node],tree[2*node+1]);
}
int query(int node,int start,int end,int p,int q)
{
    if(start>end||start>q||end<p)
        return INT_MAX;
    if(start>=p&&q>=end)
    {
        return tree[node];
    }
    int mid=(start+end)>>1;

    return min(query(2*node,start,mid,p,q),
            query(2*node+1,mid+1,end,p,q));

}
endsnippet
snippet LIS "Description" !b
int LIS(vector<int> v)
{
    set<int> m;
    for(int i=0;i<v.size();i++)
    {
        m.insert(v[i]);
        set<int>::iterator it=m.find(v[i]);
        it++;
        if(it!=m.end())
            m.erase(it);
    }
    return m.size();
}
endsnippet
snippet LNDS "Longest Non Decreasing Sequence" !b
int LNDS(vector<int> A)
{
    int N = A.size(),i;
    set<int> s;
    set<int>::iterator k;
    for (i=0;i<N;i++)
    {
        if (s.insert(A[i]).second)
        {
            k = s.find(A[i]);
            k++;
            if (k!=s.end())
                s.erase(k);
        }
    }
    return s.size();
}
endsnippet

snippet triarea "" !b
int tri_area2(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
}
int tri_area(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return abs(tri_area2(x1,y1,x2,y2,x3,y3))/2.0;
}
bool clockwise(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return tri_area2(x1,y1,x2,y2,x3,y3)<0;
}
bool counter_clockwise(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return tri_area2(x1,y1,x2,y2,x3,y3)>0;
}
endsnippet

snippet prim "Prim's Algorithm for MST" !b
    set<ii> q;
    q.insert(ii(0,0));
    ll cost=0;

    while(q.size()>0)
    {
        ii c=*(q.begin());
        q.erase(q.begin());
        int u=c.second;
        int cw=c.first;
        if(visit[u]) continue;
        cost+=cw;
        visit[u]=1;
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i];
            if(visit[v]) continue;
            q.insert(ii(w[u][i],v));
        }
    }
endsnippet
snippet scc "Strongly Connected Components Kosaraju Algorithm" !b
vector< vector<int> > g,gt;
vector<bool> used;
vector<int> order,comp;
int n;
void dfs1(int u)
{
    used[u]=true;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!used[v])
            dfs1(v);
    }
    order.push_back(u);
}
void dfs2(int u,int cl)
{
    comp[u]=cl;
    for(int i=0;i<gt[u].size();i++)
    {
        int v=gt[u][i];
        if(comp[v]==-1)
            dfs2(v,cl);
    }
}
int scc()
{
	order.clear();
    used.assign(n,false);
    for(int i=0;i<n;i++)
        if(!used[i])
            dfs1(i);
    comp.assign(n,-1);
    int c=0;
    for(int i=0;i<n;i++)
    {
        int v=order[n-i-1];
        if(comp[v]==-1)
            dfs2(v,c++);
    }
    return c;
}
endsnippet
snippet toposort "Topological Sort in lexographic order" !b
#define MAXN 1111111
vector<int> g[MAXN];
set<int> next;
vector<int> ans;
vector<int> indegree(MAXN);
int N;
void toposort()
{
    ans.clear();
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<g[i].size();j++)
        {
            indegree[g[i][j]]++;
        }
    }
    for(int i=0;i<N;i++)
    {
        if(indegree[i]==0)
            next.insert(i);
    }
    while(!next.empty())
    {
        int u=*next.begin();
        next.erase(next.begin());
        ans.push_back(u);
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i];
            indegree[v]--;
            if(!indegree[v]) next.insert(v);
        }
    }

}
endsnippet
snippet topodfs "Topological Sort using dfs" !b
vector<int> g[MAXN];
vector<int> visit(MAXN,0);
vector<int> ans;
int N;
void dfs(int u)
{
    visit[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!visit[v])
            dfs(v);
    }
    ans.push_back(u);
}
void toposort()
{
    for(int i=0;i<N;i++)
        visit[i]=0;
    ans.clear();
    for(int i=0;i<N;i++)
    {
        if(!visit[i])
            dfs(i);
    }
    reverse(ans.begin(),ans.end());
}
endsnippet
snippet dfs "Depth First Search" !b
vector<int> g[MAXN];
vector<int> intime(MAXN),outtime(MAXN);
vector<int> visit(MAXN,0);
int dfs_timer=0;
void dfs(int u)
{
    intime[u]=dfs_timer++;
    visit[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!visit[v])
            dfs(v);
    }
    outtime[u]=dfs_timer++;
}
endsnippet
snippet totient "Totinet Sieve" !b
    for(int i=1;i<MAXN;i++)
        totient[i]=i;

    for(int i=2;i<MAXN;i++)
    {
        if(totient[i]==i){// is prime
            totient[i]=i-1;
            for(int j=(2*i);j<MAXN;j+=i)
            {
                totient[j]=(totient[j])/i*(i-1);
            }
        }
    }
endsnippet
snippet nperm "k_th permutation of n numbers" !b
vector<int> get_nth(int n,int k)
{
    if(n==1)
        return vector<int>(1,0);

    int first_digit=k/factorial[n-1];
    vector<int> ans(1,first_digit);
    vector<int> rest=get_nth(n-1,k%factorial[n-1]);
    for(int i=0;i<rest.size();i++)
    {
        if(rest[i]>=first_digit)
            rest[i]++;
        ans.push_back(rest[i]);
    }
    return ans;
}
endsnippet
snippet unique "Removes Duplicates From vector" !b
sort(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());
endsnippet
snippet gauss "Gaussian Elimination" !b
#define EPS 1E-9
int gauss (vector < vector<double> > a, vector<double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return INT_MAX;
    return 1;
}
endsnippet
snippet lcp "Longest Common Prefix-Suffix" !b
vector<int> kmp_table(string pattern)
{
    int pos=1;
    int candidate=0;
    vector<int> T(pattern.length());
    T[0]=0;
    while(pos<pattern.length())
        if(pattern[pos]==pattern[candidate])
            candidate++,T[pos]=candidate,pos++;
        else if(candidate>0)
            candidate=T[candidate-1];
        else  
            T[pos]=0,pos++;
    return T;
}
endsnippet
snippet gentree  "Genrate Random Tree" !b
#define ii pair<int,int>
struct DisjointSet {
    int *root, *rank, n;
    DisjointSet(int sz) {
        root = new int[sz+1];
        rank = new int[sz+1];
        n = sz;
    }
    ~DisjointSet() {
        delete[] root;
        delete[] rank;
    }
    void init() {
        for(int i = 1; i <= n; i++) {
            root[i] = i;
            rank[i] = 0;
        }
    }
    int find(int u) {
        if(u != root[u]) root[u] = find(root[u]);
        return root[u];
    }
    void merge(int u, int v) {
        int pu = find(u);
        int pv = find(v);
        if(rank[pu] > rank[pv]) root[pv] = pu;
        else root[pu] = pv;
        if(rank[pu]==rank[pv]) rank[pv]++;
    }
};
void gentree()
{
    ofstream file;
    file.open("in");
    int n=5;
    DisjointSet ds(n);
    ds.init();
    int q;
    q=5;
    file<<n<<" "<<q<<endl;
    vector<ii> edges;
    while(edges.size()<n-1)
    {
        int a=(rand()%n)+1;
        int b=(rand()%n)+1;
        if(a==b) continue;
        if(ds.find(a)!=ds.find(b))
        {
            if(find(edges.begin(),edges.end(),ii(a,b))==edges.end()&&
                    find(edges.begin(),edges.end(),ii(b,a))==edges.end()    )
            {
                ds.merge(a,b);
                edges.push_back(ii(a,b));
            }
        }
    }
    for(int i=0;i<n;i++)
    {
        file<<rand()%10<<" ";
    }
    file<<endl;
    for(int i=0;i<edges.size();i++)
    {
        file<<edges[i].first<< " "<<edges[i].second<<endl;
    }
    //file<<endl;
    for(int i=0;i<q;i++)
    {
        if(rand()&1)
        {
            file<<"U "<<(rand()%n)+1<<" "<<(rand()%n)+1<<endl;
        }
        else
            file<<"Q "<<(rand()%n)+1<<endl;
    }
    file.close();
}
endsnippet
snippet dset "Union-Find DS" !b
struct DisjointSet {
    int *root, *rank, n;
    DisjointSet(int sz) {
        root = new int[sz+1];
        rank = new int[sz+1];
        n = sz;
    }
    ~DisjointSet() {
        delete[] root;
        delete[] rank;
    }
    void init() {
        for(int i = 1; i <= n; i++) {
            root[i] = i;
            rank[i] = 0;
        }
    }
    int find(int u) {
        if(u != root[u]) root[u] = find(root[u]);
        return root[u];
    }
    void merge(int u, int v) {
        int pu = find(u);
        int pv = find(v);
        if(rank[pu] > rank[pv]) root[pv] = pu;
        else root[pu] = pv;
        if(rank[pu]==rank[pv]) rank[pv]++;
    }
};
endsnippet
snippet invcount "inversion count" !b
vector<int> temp(maxn);
long long merge(vector<int> &v,int start,int end)
{
    long long ans=0;
    if(start<end)
    {
        int mid=start+(end-start)/2;
        ans+=merge(v,start,mid);
        ans+=merge(v,mid+1,end);
        int i=start,j=mid+1,k;

        for(k=0;i<=mid&&j<=end;k++)
        {
            if(v[i]<=v[j])
            {
                temp[k]=v[i];
                i++;
            }
            else
            {
                ans+=(mid-i+1);
                temp[k]=v[j],j++;
            }
        }
        for(;i<=mid;i++)
            temp[k++]=v[i];
        for(;j<=end;j++)
            temp[k++]=v[j];

        for(int i=start;i<=end;i++)
            v[i]=temp[i-start];
    }
    return ans;

}
endsnippet
snippet merge "Merge Sort" !b
vector<int> temp(MAXN);
int merge(vector<int> &v,int start,int end)
{
    if(start<end)
    {
        int mid=start+(end-start)/2;
        merge(v,start,mid);
        merge(v,mid+1,end);
        int i=start,j=mid+1,k;

        for(k=0;i<=mid&&j<=end;k++)
        {
            if(v[i]<v[j])
            {
                temp[k]=v[i];
                i++;
            }
            else
                temp[k]=v[j],j++;
        }
        for(;i<=mid;i++)
            temp[k++]=v[i];
        for(;j<=end;j++)
            temp[k++]=v[j];

        for(int i=start;i<=end;i++)
            v[i]=temp[i-start];
    }

}
endsnippet
snippet randdouble "Description" !b
double randdouble()
{
    return double(rand())/double(RAND_MAX);
}
endsnippet
snippet dh "" !b
cout<<"here"<<endl;
endsnippet
snippet db "Debug Macros" !b
struct debugger{template<typename T> debugger& operator,(const T& v){cerr<<v<<" ";return *this;}}dbg;
#define db(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0)
endsnippet
snippet mulmod "Eutopian Multiplication" !b
ll mulmod(ll a,ll b,ll c)
{
    ll x=0,y=a%c;
    while(b>0)
    {
        if(b&1)
        {
            x=(x+y);
            if(x>=c) x%=c;
        }
        y=(y<<1);
        if(y>=c) y%=c;
        b=b>>1;
    }
    return x;
}
endsnippet
snippet isvalid "Description" !b
if(nx>=N||nx<0||ny<0||ny>=M)
endsnippet
snippet bfs  "Bfs" !b
queue<int> q;
q.push(startx);
q.push(starty);
while(!q.empty())
{
	int cx=q.front();q.pop();
	int cy=q.front();q.pop();
	visit[cx][cy]=1;
	for(int k=0;k<4;k++)
	{
		int nx=cx+dx[k];
		int ny=cy+dy[k];

		if(nx>=N||nx<0||ny<0||ny>=M)
			continue;
		if(grid[nx][ny]!='#'&&!visit[nx][ny])
		{
			visit[nx][ny]=1;
			q.push(nx);
			q.push(ny);

		}

	}

}
endsnippet
snippet miller "Miller rabin Primility Test" !b
ll mulmod(ll a, ll b, ll c)
{
    ll x = 0, y = a%c;
    while(b>0)
    {
        if(b&1) x = (x+y)%c;
        y = (y<<1)%c;
        b = b>>1;
    }
    return x;
}
 
ll modulo(ll a, ll b, ll c)
{
    ll x = 1, y = a%c;
    while(b>0)
    {
        if(b&1) x = mulmod(x,y,c);
        y = mulmod(y,y,c);
        b = b>>1;
    }
    return x;
}
 
bool isprime(ll p, int iter)
{
    if(p<2) return false;
    if(p==2) return true;
    if(!(p&1)) return false;
    ll s = p-1, a, temp, mod;
    while(!(s&1)) s = s>>1;
    for(int i=0; i<iter; i++)
    {
        a = rand()%(p-1)+1;
        temp = s;
        mod = modulo(a, temp, p);
        while(temp!=p-1 && mod!=1 && mod!=p-1)
        {
            mod = mulmod(mod, mod, p);
            temp = temp<<1;
        }
        if(mod!=p-1 && !(temp&1)) return false;
    }
    return true;
}
endsnippet
snippet for "Description" !b
for(int i=0;i<N;i++)
{

}
endsnippet
snippet test "Description" !b
int T;scanf("%d",&T);
while(T--)
{

endsnippet
snippet split "split strings on spaces" !b
vector<string> split(std::string const &input) { 
    stringstream buffer(input);
    vector<std::string> ret;
 
    copy(istream_iterator<string>(buffer), 
              std::istream_iterator<std::string>(),
              std::back_inserter(ret));
    return ret;
}
endsnippet
snippet point "point libary" !b
const double PI = acos(-1.0);
const double EPS = 1E-8;

bool zero(double x)
{
	return -EPS < x && x < EPS;
}

int sgn(double x)
{
	return x > EPS ? 1 : (x < -EPS ? -1 : 0);
}

class Point
{
	public:
	double x, y;
	Point() {}
	Point(double x, double y) : x(x), y(y) {}
	void init()
	{
		scanf("%lf%lf", &x, &y);
	}
	void print() const
	{
		printf("Point(%lf %lf)\n", x, y);
	}
	bool operator < (const Point & rhs) const
	{
		return x < rhs.x - EPS || (zero(x - rhs.x) && y < rhs.y - EPS);
		}
	bool operator == (const Point & rhs) const
	{
		return zero(x - rhs.x) && zero(y - rhs.y);
		}
	Point operator - (const Point & rhs) const
	{
		return Point(x - rhs.x, y - rhs.y);
		}
	Point operator + (const Point & rhs) const
	{
		return Point(x + rhs.x, y + rhs.y);
		}
	Point operator * (const double scale) const
	{
		return Point(x * scale, y * scale);
		}
	Point operator / (const double scale) const
	{
		return Point(x / scale, y / scale);
		}
	double operator * (const Point & rhs) const
	{
		return x * rhs.y - rhs.x * y;
		}
	double operator ^ (const Point & rhs) const
	{
		return x * rhs.x + y * rhs.y;
		}
	Point rotate(double angle) const
	{
		Point p(sin(angle), cos(angle));
		return Point((*this) * p, (*this) ^ p);
	}
	double length2() const
	{
		return x * x + y * y;
	}
	double length() const
	{
		return sqrt(this->length2());
		}
	Point trunc(const double scale) const
	{
		return (*this) / this->length() * scale;
		}
	double angle() const
	{
		return atan2(y, x);
		}
	Point perpendicular() const
	{
		return Point(-y, x);
		}
};

class Line
{
	public:
		Point l1, l2;
		Line() {}
		Line(Point l1, Point l2) : l1(l1), l2(l2) {}
		void init()
		{
			l1.init();
			l2.init();
		}
		void print() const
		{
			printf("Line[(%lf %lf)--(%lf %lf)]\n", l1.x, l1.y, l2.x, l2.y);
			}
		bool cross(const Point & p) const
		{
			return zero((p - l2) * (l1 - l2));
		}
		bool cross(const Line &rhs) const
		{
			return !this->parallel(rhs);
			}
		bool parallel(const Line &rhs) const
		{
			return zero((l1 - l2) * (rhs.l1 - rhs.l2));
		}
		Point intersection(const Line &rhs) const
		{
			return l1 + (l2 - l1) * (((l1 - rhs.l1) * (rhs.l1 - rhs.l2)) / ((l1 - l2) * (rhs.l1 - rhs.l2)));
		}
		Point projection(const Point &p) const
		{
			return this->intersection(Line(p, p + (l1 - l2).perpendicular()));
		}
		double distance(const Point &p) const
		{
			return ((p - l1) * (l2 - l1)) / (l1 - l2).length();
		}
		//For finding the perpendicular bisector of a line.
		Line perpendicular_bisector() const
		{
			Point p1=Point( (l1.x+l2.x)/2 , (l1.y+l2.y)/2);
			double m;
			Point p2;
			if( zero(l1.x-l2.x) )
			{
				m=0;
				p2=Point(p1.x+10, p1.y);
			}
			else{
				m=(l1.y-l2.y)/(l1.x-l2.x);
				if( zero(m) )
				{
					p2=Point(p1.x, p1.y+10);
				}
				else
				{
					m=-1/m;
					p2=Point(p1.x+10, p1.y+(10*m));
				}
			}
			return Line(p1, p2);
		}
};

//Finding the area of a polygon, all points must be in order.
double Area(vector<Point> &v)
{
	int n=v.size();

	double area=0;

	for(int i=1; i<n-1; i++)
	{
		Point p1=v[i]-v[0];
		Point p2=v[i+1]-v[0];
		//cout << p1*p2<< endl;
		area+= (p1*p2);
	}
	return abs(area/2);
}
endsnippet
snippet iii "iii" !b
#define iii pair< int,pair<int,int> >
endsnippet
snippet dj "Dijstras" !b
multiset<ii> q;

q.insert(ii(0,N));
vector<int> d(N+2,INT_MAX);
vector<int> visit(N+2,0);
d[N]=0;

while(q.size()>0)
{
	ii c=*q.begin();
	q.erase(q.begin());
	if(c.second==N+1)
		break;
	if(visit[c.second]) continue;
	visit[c.second]=1;

	for(int i=0;i<N+2;i++)
	{
		if(visit[i]) continue;
		if(d[i]>c.first+dist(i,c.second))
		{
			d[i]=c.first+dist(i,c.second);
			q.insert(ii(d[i],i));
		}

	}

}
endsnippet
snippet segtree "Segment Tree" !b
#define MAXN 111111
struct node{
    ll sum;
    bool lazy;
    ll add;
    int l,r;
    node()
    {
        sum=0;lazy=0;add=0;
    }
    node(int a,int b,int c):
        sum(a),lazy(b),add(c){}
};
vector<int> v;
node tree[3*MAXN];
void combine(node &c,node &a,node &b)
{
    c.sum=a.sum+b.sum;
    c.lazy=0;
    c.add=0;
}
void build(int index,int start,int end)
{
    tree[index].l=start;
    tree[index].r=end;
    if(start==end)
    {
        tree[index].lazy=0;
        tree[index].add=0;
        tree[index].sum=v[start];
        return;
    }
    int mid=(start+end)>>1;
    build(2*index,start,mid);
    build(2*index+1,mid+1,end);

    combine(tree[index],tree[2*index],tree[2*index+1]);
}
void fixnode(node &a)
{
    a.sum+=(ll)(a.r-a.l+1)*a.add;
    a.add=0;
    a.lazy=0;
}
void pushupdate(node &a,node &b,node &c)
{
    b.add+=a.add;
    c.add+=a.add;
    b.lazy=1;
    c.lazy=1;
}
void update(int index,int start,int end,int p,int q,int value)
{
    if(tree[index].lazy)
    {
        if(start!=end)
            pushupdate(tree[index],tree[2*index],tree[2*index+1]);
        fixnode(tree[index]);

    }
    if(start>end||start>q||end<p)
        return;
    if(start>=p&&q>=end)
    {
        tree[index].add=value;
        if(start!=end)
        {
            pushupdate(tree[index],tree[2*index],tree[2*index+1]);
        }
        fixnode(tree[index]);
        return;
    }
    int mid=(start+end)>>1;

    update(2*index,start,mid,p,q,value);
    update(2*index+1,mid+1,end,p,q,value);

    combine(tree[index],tree[2*index],tree[2*index+1]);

}
node query(int index,int start,int end,int p,int q)
{

    if(tree[index].lazy)
    {
        if(start!=end)
            pushupdate(tree[index],tree[2*index],tree[2*index+1]);
        fixnode(tree[index]);
    }
    if(start>=p&&end<=q)
    {
        return tree[index];
    }
    int mid=(start+end)>>1;

    if(q<=mid)
        return query(2*index,start,mid,p,q);
    else if(p>mid)
        return query(2*index+1,mid+1,end,p,q);

    node q1=query(2*index,start,mid,p,q);
    node q2=query(2*index+1,mid+1,end,p,q);
    node ret;
    combine(ret,q1,q2);
    return ret;

}
int main()
{
    freopen("in","r",stdin);

    int N,q;
    s(N);
    v.resize(N,0);
    build(1,0,N-1);
    s(q);
    while(q--)
    {
        int t;s(t);
        if(!t)
        {
            int a,b,c;s(a);s(b);s(c);a--;b--;
            update(1,0,N-1,a,b,c);
        }
        else
        {
            int a,b;s(a);s(b);a--;b--;
            int ans=query(1,0,N-1,a,b);
            printf("%d\n",ans);
        }
    }


    return 0;
}
endsnippet
snippet sieveip "sieve is prime " !b
bool isprime(int n)
{
	if(n<2) return 0;
	if(n==2) return 1;
	if(!(n&1)) return 0;
	else
		return !mark[n>>1];
}
endsnippet
snippet sieve "sieve" !b
vector<bool> mark(MAXN>>1);
vector<int> primes;
void sieve()
{
    primes.push_back(2);
    int i;
    for(i=3;i*i<MAXN;i+=2)
    {
        if(!mark[i>>1])
        {
            for(int j=i*i;j<MAXN;j+=2*i)
            {
                mark[j>>1]=1;	
            }
            primes.push_back(i);
        }
    
    }
    for(;i<MAXN;i+=2)
    {
        if(!mark[i>>1])
        {
            primes.push_back(i);
        }
    }
}
endsnippet
snippet factorize "factorize" !b
#define ii pair<ll,ll>
vector<ii> factorize(ll x)
{
    vector<ii> ret;
    for(ll i=2;i*i<=x;i++)
    {
        ll cnt=0;
        while(x%i==0)
        {
            x/=i;
            cnt++;
        }
        if(cnt)
            ret.push_back(ii(i,cnt));
    }
    if(x>1)
        ret.push_back(ii(x,1));
    return ret;
}
vector<int> factorize(int x)
{
    vector<int> ret;
    for(int i=0;i<primes.size();i++)
    {
        while(x%primes[i]==0)
        {
            x/=primes[i];
            ret.push_back(primes[i]);
        }
    }
    return ret;
}
endsnippet
snippet tobinary "tobianary" !b
string tobinary(int x)
{
    string ret;
    while(x!=0)
    {
        ret=(char)(x%2+'0')+ret;
        x>>=1;
    }
    return ret;
}
endsnippet
snippet knightdir "knights direction arrays" !b
int dx[]={1,2,1,2,-1,-2,-1,-2};
int dy[]={2,1,-2,-1,2,1,-2,-1};
endsnippet
snippet bit "binary indexed tree" !b
int tree[MAXN];
void update(int index,int value)
{
	assert(index!=0);
	while(index<MAXN)
	{
		tree[index]+=value;
		index+=(index&-index);
	}
}
int sum(int index)
{
	int s=0;
	while(index>0)
	{
		s+=tree[index];
		index-=(index&-index);
	}
	return s;
}
endsnippet
snippet gentest "genernating testcases function" !b
void gentests()
{
    ofstream file;
    file.open("in");
    int test=1;
	file<<test<<endl;
    while(test--)
    {
        int n=10000;
        file<<n<<endl;
        for(int i=0;i<n;i++)
        {
            file<<(rand())<<" " ;
        }
        file<<endl;
    }
	file.close();
}
endsnippet
snippet pll "description" !b
printf("%lld\n",$1);
endsnippet
snippet p "Description" !b
printf("%d\n",$1);
endsnippet
snippet iarray "input an array" !b
for(int i=0;i<N;i++)
{
	s(v[i]);
}
endsnippet
snippet igrid "input a Matrix" !b
scanf("%d %d",&N,&M);
for(int i=0;i<N;i++)
{
	scanf("%s",temp);
	for(int j=0;j<M;j++)
	{
		grid[i][j]=temp[j];
	}
}
endsnippet
snippet dir2 "directions2 " !b
int dx2[]={1,-1,0,0,1,-1,1,-1};
int dy2[]={0,0,-1,1,-1,1,1,-1};
endsnippet
snippet dir "directions " !b
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
endsnippet
snippet toint "toint" !b
int toint(string str)
{
    istringstream is(str);
    int x;
    is>>x;
    return x;
}
endsnippet
snippet tostring "tostring function c++" !b
string tostring(int x)
{
    ostringstream os;
    os<<x;
    return os.str();
}
endsnippet
snippet ii "define pair" !b
#define ii pair<int,int>
endsnippet
snippet ll "define ll" !b
#define ll long long
endsnippet
snippet mod "define mod" !b
#define mod 1000000007
endsnippet
snippet maxn "define max" !b
#define MAXN 1111111
endsnippet
snippet modpow "modpow function" !b
long long modpow(long long n,long long p)
{
    long long ret=1;
    while(p)
    {
        if(p&1){
            ret=ret*n;
            if(ret>=mod) ret%=mod;
        }

        p=p/2;
        n*=n;
        if(n>=mod)
            n%=mod;
    }
    return ret;
}
endsnippet
snippet fastio "fast i/o class" !b
static struct io {
        char tmp[1 << 10];
 
        // fast input routines
        char cur;
 
//#define nextChar() (cur = getc_unlocked(stdin))
//#define peekChar() (cur)
        inline char nextChar() { return cur = getc_unlocked(stdin); }
        inline char peekChar() { return cur; }
 
        inline operator bool() { return peekChar(); }
        inline static bool isBlank(char c) { return (c < '-' && c); }
        inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }
 
        inline IO& operator >> (char & c) { c = nextChar(); return *this; }
 
        inline IO& operator >> (char * buf) {
                if (skipBlanks()) {
                        if (peekChar()) {
                                *(buf++) = peekChar();
                                while (!isBlank(nextChar())) *(buf++) = peekChar();
                        } *(buf++) = 0; } return *this; }
 
        inline IO& operator >> (string & s) {
                if (skipBlanks()) {     s.clear(); s += peekChar();
                        while (!isBlank(nextChar())) s += peekChar(); }
                return *this; }
 
        inline IO& operator >> (double & d) { if ((*this) >> tmp) sscanf(tmp, "%lf", &d); return *this; }
 
#define defineInFor(intType) \
        inline IO& operator >>(intType & n) { \
                if (skipBlanks()) { \
                        int sign = +1; \
                        if (peekChar() == '-') { \
                                sign = -1; \
                                n = nextChar() - '0'; \
                        } else \
                                n = peekChar() - '0'; \
                        while (!isBlank(nextChar())) { \
                                n += n + (n << 3) + peekChar() - 48; \
                        } \
                        n *= sign; \
                } \
                return *this; \
        }
 
defineInFor(int)
defineInFor(unsigned int)
defineInFor(long long)
 
        // fast output routines
 
//#define putChar(c) putc_unlocked((c), stdout)
        inline void putChar(char c) { putc_unlocked(c, stdout); }
        inline IO& operator << (char c) { putChar(c); return *this; }
        inline IO& operator << (const char * s) { while (*s) putChar(*s++); return *this; }
 
        inline IO& operator << (const string & s) { for (int i = 0; i < (int)s.size(); ++i) putChar(s[i]); return *this; }
 
        char * toString(double d) { sprintf(tmp, "%lf%c", d, '\0'); return tmp; }
        inline IO& operator << (double d) { return (*this) << toString(d); }
 
 
#define defineOutFor(intType) \
        inline char * toString(intType n) { \
                char * p = (tmp + 30); \
                if (n) { \
                        bool isNeg = 0; \
                        if (n < 0) isNeg = 1, n = -n; \
                        while (n) \
                                *--p = (n % 10) + '0', n /= 10; \
                        if (isNeg) *--p = '-'; \
                } else *--p = '0'; \
                return p; \
        } \
        inline IO& operator << (intType n) { return (*this) << toString(n); }
 
defineOutFor(int)
defineOutFor(long long)
 
#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;
endsnippet
snippet bigint "bigint libary" !b
const int base = 1000000000;
const int base_digits = 9;

struct bigint {
    vector<int> a;
    int sign;

    bigint() :
        sign(1) {
        }

    bigint(long long v) {
        *this = v;
    }

    bigint(const string &s) {
        read(s);
    }

    void operator=(const bigint &v) {
        sign = v.sign;
        a = v.a;
    }

    void operator=(long long v) {
        sign = 1;
        if (v < 0)
            sign = -1, v = -v;
        for (; v > 0; v = v / base)
            a.push_back(v % base);
    }

    bigint operator+(const bigint &v) const {
        if (sign == v.sign) {
            bigint res = v;

            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {
                if (i == (int) res.a.size())
                    res.a.push_back(0);
                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);
                carry = res.a[i] >= base;
                if (carry)
                    res.a[i] -= base;
            }
            return res;
        }
        return *this - (-v);
    }

    bigint operator-(const bigint &v) const {
        if (sign == v.sign) {
            if (abs() >= v.abs()) {
                bigint res = *this;
                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {
                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);
                    carry = res.a[i] < 0;
                    if (carry)
                        res.a[i] += base;
                }
                res.trim();
                return res;
            }
            return -(v - *this);
        }
        return *this + (-v);
    }

    void operator*=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
            if (i == (int) a.size())
                a.push_back(0);
            long long cur = a[i] * (long long) v + carry;
            carry = (int) (cur / base);
            a[i] = (int) (cur % base);
            //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
        }
        trim();
    }

    bigint operator*(int v) const {
        bigint res = *this;
        res *= v;
        return res;
    }

    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {
        int norm = base / (b1.a.back() + 1);
        bigint a = a1.abs() * norm;
        bigint b = b1.abs() * norm;
        bigint q, r;
        q.a.resize(a.a.size());

        for (int i = a.a.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.a[i];
            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];
            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
            int d = ((long long) base * s1 + s2) / b.a.back();
            r -= b * d;
            while (r < 0)
                r += b, --d;
            q.a[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm);
    }

    bigint operator/(const bigint &v) const {
        return divmod(*this, v).first;
    }

    bigint operator%(const bigint &v) const {
        return divmod(*this, v).second;
    }

    void operator/=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = a[i] + rem * (long long) base;
            a[i] = (int) (cur / v);
            rem = (int) (cur % v);
        }
        trim();
    }

    bigint operator/(int v) const {
        bigint res = *this;
        res /= v;
        return res;
    }

    int operator%(int v) const {
        if (v < 0)
            v = -v;
        int m = 0;
        for (int i = a.size() - 1; i >= 0; --i)
            m = (a[i] + m * (long long) base) % v;
        return m * sign;
    }

    void operator+=(const bigint &v) {
        *this = *this + v;
    }
    void operator-=(const bigint &v) {
        *this = *this - v;
    }
    void operator*=(const bigint &v) {
        *this = *this * v;
    }
    void operator/=(const bigint &v) {
        *this = *this / v;
    }

    bool operator<(const bigint &v) const {
        if (sign != v.sign)
            return sign < v.sign;
        if (a.size() != v.a.size())
            return a.size() * sign < v.a.size() * v.sign;
        for (int i = a.size() - 1; i >= 0; i--)
            if (a[i] != v.a[i])
                return a[i] * sign < v.a[i] * sign;
        return false;
    }

    bool operator>(const bigint &v) const {
        return v < *this;
    }
    bool operator<=(const bigint &v) const {
        return !(v < *this);
    }
    bool operator>=(const bigint &v) const {
        return !(*this < v);
    }
    bool operator==(const bigint &v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const bigint &v) const {
        return *this < v || v < *this;
    }

    void trim() {
        while (!a.empty() && !a.back())
            a.pop_back();
        if (a.empty())
            sign = 1;
    }

    bool isZero() const {
        return a.empty() || (a.size() == 1 && !a[0]);
    }

    bigint operator-() const {
        bigint res = *this;
        res.sign = -sign;
        return res;
    }

    bigint abs() const {
        bigint res = *this;
        res.sign *= res.sign;
        return res;
    }

    long long longValue() const {
        long long res = 0;
        for (int i = a.size() - 1; i >= 0; i--)
            res = res * base + a[i];
        return res * sign;
    }

    friend bigint gcd(const bigint &a, const bigint &b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend bigint lcm(const bigint &a, const bigint &b) {
        return a / gcd(a, b) * b;
    }

    void read(const string &s) {
        sign = 1;
        a.clear();
        int pos = 0;
        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-')
                sign = -sign;
            ++pos;
        }
        for (int i = s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for (int j = max(pos, i - base_digits + 1); j <= i; j++)
                x = x * 10 + s[j] - '0';
            a.push_back(x);
        }
        trim();
    }

    int length(){
        int l=0,back=a.back();
        while(back){l++;back/=10;}
        l+=((a.size()-1)*base_digits);
        return l;
    }

    friend istream& operator>>(istream &stream, bigint &v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream &stream, const bigint &v) {
        if (v.sign == -1)
            stream << '-';
        stream << (v.a.empty() ? 0 : v.a.back());
        for (int i = (int) v.a.size() - 2; i >= 0; --i)
            stream << setw(base_digits) << setfill('0') << v.a[i];
        return stream;
    }

    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int) p.size(); i++)
            p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back(int(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int) cur);
        while (!res.empty() && !res.back())
            res.pop_back();
        return res;
    }

    typedef vector<long long> vll;

    static vll karatsubaMultiply(const vll &a, const vll &b) {
        int n = a.size();
        vll res(n + n);
        if (n <= 32) {
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    res[i + j] += a[i] * b[j];
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        for (int i = 0; i < k; i++)
            a2[i] += a1[i];
        for (int i = 0; i < k; i++)
            b2[i] += b1[i];

        vll r = karatsubaMultiply(a2, b2);
        for (int i = 0; i < (int) a1b1.size(); i++)
            r[i] -= a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            r[i] -= a2b2[i];

        for (int i = 0; i < (int) r.size(); i++)
            res[i + k] += r[i];
        for (int i = 0; i < (int) a1b1.size(); i++)
            res[i] += a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            res[i + n] += a2b2[i];
        return res;
    }

    bigint operator*(const bigint &v) const {
        vector<int> a6 = convert_base(this->a, base_digits, 6);
        vector<int> b6 = convert_base(v.a, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while (a.size() < b.size())
            a.push_back(0);
        while (b.size() < a.size())
            b.push_back(0);
        while (a.size() & (a.size() - 1))
            a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        bigint res;
        res.sign = sign * v.sign;
        for (int i = 0, carry = 0; i < (int) c.size(); i++) {
            long long cur = c[i] + carry;
            res.a.push_back((int) (cur % 1000000));
            carry = (int) (cur / 1000000);
        }
        res.a = convert_base(res.a, 6, base_digits);
        res.trim();
        return res;
    }
};
endsnippet
