snippet bpm "Bipartite Matching" !b
vector<int> visit;
vector<int> match;
int edge[MAXN][MAXN];
int n,m;
int dfs(int u)
{
    if(visit[u]) return false;
    visit[u]=1;
    for(int i=0;i<n;i++)
    {
        if(!edge[u][i]) continue;
        if(match[i]==-1||dfs(match[i]))
        {
            match[i]=u;
            return true;
        }
    }
    return false;
}
int bmp()
{
    int matched=0;
    match.assign(m,-1);

    for(int i=0;i<n;i++)
    {
        visit.assign(n,0);
        if(dfs(i))
            matched++;
    }
    return matched;

}
endsnippet
snippet mincostmatch "Hungerian Algorithm for mincost matching in Bipartite Graph O(N^2*M)" !b
#define INF INT_MAX
int n,m;
vector< vector<int> > a;
vector<int> ans;
//if perfect maching is required add infinity to missing edges otherwise add 0
int min_cost_match(){

    vector<int> u(n+1),v(m+1),p(m+1),way(m+1);

    for(int i=1;i<=n;++i) 
    {
        p[0] = i;
        int j0 = 0;
        vector<int> minv (m+1, INF);
        vector<char> used (m+1, false);
        do {
            used[j0] = true;
            int i0 = p[j0],  delta = INF,  j1;
            for (int j=1; j<=m; ++j)
                if (!used[j]) {
                    int cur = a[i0][j]-u[i0]-v[j];
                    if (cur < minv[j])
                        minv[j] = cur,  way[j] = j0;
                    if (minv[j] < delta)
                        delta = minv[j],  j1 = j;
                }
            for (int j=0; j<=m; ++j)
                if (used[j])
                    u[p[j]] += delta,  v[j] -= delta;
                else
                    minv[j] -= delta;
            j0 = j1;
        }
        while (p[j0] != 0);
        do {
            int j1 = way[j0];
            p[j0] = p[j1];
            j0 = j1;
        }
        while (j0);
    }
    ans.resize(n+1);
    for(int i=1;i<=m;i++)
    {
        ans[p[i]]=i;
    }
    //for(int i=1;i<=n;i++)
    //{
        //cout<<ans[i]<<" ";
    //}
    //cout<<endl;

    int cost=-v[0];
    return cost; 
}
endsnippet
snippet ss "String scanf" !b
scanf("%s",str);
endsnippet
snippet suffixarray "Suffix Array" !b
char str[MAXN];
const int alphabet=256;
int log_n;
int n;
vector< vector<int> > cns;
vector< int> sa;
int compare (int i, int j, int l) //compare to strings of len l in contant time
{
    int k=0;
    while((1<<k)<l)
        k++;
    if((1<<k)>l) k--;

    pair<int,int> a = make_pair (cns[k][i], cns[k][i+l-(1<<k)]);
    pair<int,int> b = make_pair (cns[k][j], cns[k][j+l-(1<<k)]);
    return a == b ? 0 : a < b ? -1 : 1;
}
int lcp(int i,int j) //longest common prefix of substrings at index i and j
{
    int len=0;
    int oi=i,oj=j;
    for(int k=cns.size()-1;k>=0;k--)
    {
        if(cns[k][i]==cns[k][j])
        {
            len+=(1<<k);
            i+=(1<<k);
            j+=(1<<k);
        }
    }
    return (min(min(n-oi,n-oj),len));

}
void suffix()
{

    cns.clear();
    vector<int> cnt(max(alphabet,n),0);
    vector<int> p(n);
    vector<int> c(n);

    for (int i=0; i<n; ++i)
        ++cnt[str[i]];

    for (int i=1; i<alphabet; ++i)
        cnt[i] += cnt[i-1];
    for (int i=0; i<n; ++i)
        p[--cnt[str[i]]] = i;

    c[p[0]] = 0;

    int classes = 1;
    for (int i=1; i<n; ++i) {
        if (str[p[i]] != str[p[i-1]])  ++classes;
        c[p[i]] = classes-1;
    }
    cns.push_back(c);
    vector<int> pn(n);
    vector<int> cn(n);
    for (int h=0; (1<<h)<n; ++h) {
        for (int i=0; i<n; ++i) {
            pn[i] = p[i] - (1<<h);
            if (pn[i] < 0)  pn[i] += n;
        }
        for(int i=0;i<classes;i++) cnt[i]=0;

        for (int i=0; i<n; ++i)
            ++cnt[c[pn[i]]];
        for (int i=1; i<classes; ++i)
            cnt[i] += cnt[i-1];
        for (int i=n-1; i>=0; --i)
            p[--cnt[c[pn[i]]]] = pn[i];
        cn[p[0]] = 0;
        classes = 1;
        for (int i=1; i<n; ++i) {
            int mid1 = (p[i] + (1<<h)) % n,  mid2 = (p[i-1] + (1<<h)) % n;
            if (c[p[i]] != c[p[i-1]] || c[mid1] != c[mid2])
                ++classes;
            cn[p[i]] = classes-1;
        }
        c=cn;
        cns.push_back(c);
    }
    sa=p;
    for(int i=0;i<sa.size();i++)
    {
		cout<<sa[i]<<" ";
    }
    cout<<endl;
}
endsnippet

snippet fordadj "Ford Fukerson for large graphs" !b
struct edge {
    int a, b, cap, flow;
};
vector<edge> e;
vector<int> g[MAXN];
int visit[MAXN];
int n;
int s,t;
int limit=INT_MAX;
void add_edge (int a, int b, int cap) {
    edge e1 = { a, b, cap, 0 };
    edge e2 = { b, a, 0, 0 };
    g[a].push_back ((int) e.size());
    e.push_back (e1);
    g[b].push_back ((int) e.size());
    e.push_back (e2);
}
int dfs(int u,int t,int c)
{
    if(visit[u])
        return false;
    visit[u]=1;
    if(u==t) return true;
    for (int i=0; i<g[u].size();i++) {
        int id = g[u][i],
            to = e[id].b;
        if((e[id].cap-e[id].flow)>=c&&dfs(to,t,c))
        {
            e[id].flow+=c;
            e[id^1].flow-=c;
            return true;
        }
    }
    return false;
}
int maxflow()
{
    int flow=0;
    int c=limit;
    while(c)
    {
        for(int i=0;i<n;i++) visit[i]=0;
        int f=dfs(s,t,c);
        if(!f)
            c/=2;
        else
            flow+=c;
        if(flow>=limit)
            return flow=limit;
    }
    return flow;
}
endsnippet

snippet fordmatrix "Ford Fukkerson Maxflow using Capicty Matrix" !b
#define INF INT_MAX 
int cap[MAXN][MAXN];
int visit[MAXN];
int n;
int s,t;
int limit=INT_MAX;
int dfs(int u,int t,int c)
{
    if(visit[u])
        return false;
    visit[u]=1;
    if(u==t) return true;
    for(int i=0;i<n;i++)
    {
        if(cap[u][i]>=c&&dfs(i,t,c))
        {
            cap[u][i]-=c;
            cap[i][u]+=c;
            return true;
        }
    }
    return false;
}
int maxflow()
{
    int flow=0;
    int c=limit;
    while(c)
    {
        for(int i=0;i<n;i++) visit[i]=0;
        int f=dfs(s,t,c);
        if(!f)
            c/=2;
        else
            flow+=c;
        if(flow>=limit)
            return flow=limit;
    }
    return flow;
}
endsnippet

snippet dinic "Description" !b
const int INF = INT_MAX;
int n, c[MAXN][MAXN], f[MAXN][MAXN], s, t, d[MAXN], ptr[MAXN], q[MAXN];
bool bfs() {
    int qh=0, qt=0;
    q[qt++] = s;
    memset (d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt) {
        int v = q[qh++];
        for (int to=0; to<n; ++to)
            if (d[to] == -1 && f[v][to] < c[v][to]) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
    }
    return d[t] != -1;
}

int dfs (int v, int flow) {
    if (!flow)  return 0;
    if (v == t)  return flow;
    for (int & to=ptr[v]; to<n; ++to) {
        if (d[to] != d[v] + 1)  continue;
        int pushed = dfs (to, min (flow, c[v][to] - f[v][to]));
        if (pushed) {
            f[v][to] += pushed;
            f[to][v] -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())  break;
        memset (ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs (s, INF))
            flow += pushed;
    }
    return flow;
}

endsnippet
snippet egcd "Extended GCD" !b
int egcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    
    int x1,y1;
    int d=egcd(b,a%b,x1,y1);
    y=x1;
    x=y1-(b/a)*x1;
    return d;
}
endsnippet
snippet phifast "phifast" !b
int totient[MAXN];
vector<bool> mark(MAXN>>1);
int lf[MAXN];
int phi(int n)
{
    int ret=n;
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0) ret-=ret/i;
        while(n%i==0)
            n/=i;
    }
    if(n>1)
        ret-=ret/n;
    return ret;
}
bool isprime(int n)
{
    if(n<2) return 0;
    if(n==2) return 1;
    if(!(n&1)) return 0;
    else
        return !mark[n>>1];
}
int phifast(int n)
{
    if(totient[n]) return totient[n];
    if(n<=1) return 1;

    if(isprime(n))
        return totient[n]=n-1;

    if(!(n&1))
    {
        int m=n>>1;
        if((m&1))
            return totient[n]=phifast(m);
        else
            return totient[n]=phifast(m)<<1;
    }

    int o=n/lf[n];
    int m=lf[n];
    int g=__gcd(m,o);

    if(g==1)
        return totient[n]=phifast(m)*phifast(o);
    else
        return totient[n]=phifast(m)*phifast(o)*g/phifast(g);

}
void sieve()
{
    int i;
    for(i=3;i*i<MAXN;i+=2)
    {
        if(!mark[i>>1])
        {
            for(int j=i*i;j<MAXN;j+=2*i)
            {
                mark[j>>1]=1;	
                lf[j]=i;

            }
        }
    
    }
}

endsnippet
snippet phi "Single Totinet" !b
int phi(int n)
{
    int ret=n;
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0) ret-=ret/i;
        while(n%i==0)
            n/=i;
    }
    if(n>1)
        ret-=ret/n;
    return ret;
}
endsnippet
snippet rmq "Range Min Query" !b
#define MAXN 111111
int tree[4*MAXN];
int lazy[4*MAXN];
vector<int> v;
int N;
void build(int node,int start,int end)
{
    if(start>end)
        return ;
    if(start==end)
    {
        tree[node]=v[start-1];
        return ; 
    }

    int mid=(start+end)>>1;
    build(2*node,start,mid);
    build(2*node+1,mid+1,end);

    tree[node]=min(tree[2*node],tree[2*node+1]);
}
void update(int node,int start,int end,int index,int value)
{
    if(start>end)
        return ;
    if(start==end)
    {
        tree[node]=value;
        return ;
    }
    int mid=(start+end)>>1;
    if(index<=mid)
        update(2*node,start,mid,index,value);
    else
        update(2*node+1,mid+1,end,index,value);

    tree[node]=min(tree[2*node],tree[2*node+1]);
}
int query(int node,int start,int end,int p,int q)
{
    if(start>end||start>q||end<p)
        return INT_MAX;
    if(start>=p&&q>=end)
    {
        return tree[node];
    }
    int mid=(start+end)>>1;

    return min(query(2*node,start,mid,p,q),
            query(2*node+1,mid+1,end,p,q));

}
endsnippet

snippet LNDS "Longest Non Decreasing Sequence" !b
int LNDS(vector<int> A)
{
    int N = A.size(),i;
    set<int> s;
    set<int>::iterator k;
    for (i=0;i<N;i++)
    {
        if (s.insert(A[i]).second)
        {
            k = s.find(A[i]);
            k++;
            if (k!=s.end())
                s.erase(k);
        }
    }
    return s.size();
}
endsnippet

snippet triarea "" !b
int tri_area2(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
}
int tri_area(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return abs(tri_area2(x1,y1,x2,y2,x3,y3))/2.0;
}
bool clockwise(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return tri_area2(x1,y1,x2,y2,x3,y3)<0;
}
bool counter_clockwise(int x1,int y1,int x2,int y2,int x3,int y3)
{
    return tri_area2(x1,y1,x2,y2,x3,y3)>0;
}
endsnippet

snippet prim "Prim's Algorithm for MST" !b
    set<ii> q;
    q.insert(ii(0,0));
    ll cost=0;

    while(q.size()>0)
    {
        ii c=*(q.begin());
        q.erase(q.begin());
        int u=c.second;
        int cw=c.first;
        if(visit[u]) continue;
        cost+=cw;
        visit[u]=1;
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i];
            if(visit[v]) continue;
            q.insert(ii(w[u][i],v));
        }
    }
endsnippet
snippet scc "Strongly Connected Components Kosaraju Algorithm" !b
vector<int> g[MAXN],gr[MAXN];
vector<int> visit(MAXN,0);
vector<int> order;
vector<int> component(MAXN);
int N;
void dfs_order(int u)
{
    visit[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!visit[v])
            dfs_order(v);
    }
    order.push_back(u);
}
void dfs(int u,int c)
{
    visit[u]=1;
    component[u]=c;
    for(int i=0;i<gr[u].size();i++)
    {
        int v=gr[u][i];
        if(!visit[v])
            dfs(v,c);
    }
}
int scc()
{
    for(int i=0;i<N;i++)
        visit[i]=0;
    order.clear();
    for(int i=0;i<N;i++)
    {
        if(!visit[i])
            dfs_order(i);
    }

    reverse(order.begin(),order.end());
    int c=0;
    for(int i=0;i<N;i++)
        visit[i]=0;

    for(int i=0;i<n;i++)
    {
        int v=order[i];
        if(!visit[v])
        {
            dfs(v,c);
            c++;
        }
    }
    return c;
}

endsnippet
snippet toposort "Topological Sort in lexographic order" !b
#define MAXN 1111111
vector<int> g[MAXN];
set<int> next;
vector<int> ans;
vector<int> indegree(MAXN);
int N;
void toposort()
{
    ans.clear();
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<g[i].size();j++)
        {
            indegree[g[i][j]]++;
        }
    }
    for(int i=0;i<N;i++)
    {
        if(indegree[i]==0)
            next.insert(i);
    }
    while(!next.empty())
    {
        int u=*next.begin();
        next.erase(next.begin());
        ans.push_back(u);
        for(int i=0;i<g[u].size();i++)
        {
            int v=g[u][i];
            indegree[v]--;
            if(!indegree[v]) next.insert(v);
        }
    }

}
endsnippet
snippet topodfs "Topological Sort using dfs" !b
vector<int> g[MAXN];
vector<int> visit(MAXN,0);
vector<int> ans;
int N;
void dfs(int u)
{
    visit[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!visit[v])
            dfs(v);
    }
    ans.push_back(u);
}
void toposort()
{
    for(int i=0;i<N;i++)
        visit[i]=0;
    ans.clear();
    for(int i=0;i<N;i++)
    {
        if(!visit[i])
            dfs(i);
    }
    reverse(ans.begin(),ans.end());
}
endsnippet
snippet dfs "Depth First Search" !b
vector<int> g[MAXN];
vector<int> intime(MAXN),outtime(MAXN);
vector<int> visit(MAXN,0);
int dfs_timer=0;
void dfs(int u)
{
    intime[u]=dfs_timer++;
    visit[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!visit[v])
            dfs(v);
    }
    outtime[u]=dfs_timer++;
}
endsnippet
snippet totient "Totinet Sieve" !b
    for(int i=1;i<MAXN;i++)
        totient[i]=i;

    for(int i=2;i<MAXN;i++)
    {
        if(totient[i]==i){// is prime
            totient[i]=i-1;
            for(int j=(2*i);j<MAXN;j+=i)
            {
                totient[j]=(totient[j])/i*(i-1);
            }
        }
    }
endsnippet
snippet nperm "k_th permutation of n numbers" !b
vector<int> get_nth(int n,int k)
{
    if(n==1)
        return vector<int>(1,0);

    int first_digit=k/factorial[n-1];
    vector<int> ans(1,first_digit);
    vector<int> rest=get_nth(n-1,k%factorial[n-1]);
    for(int i=0;i<rest.size();i++)
    {
        if(rest[i]>=first_digit)
            rest[i]++;
        ans.push_back(rest[i]);
    }
    return ans;
}
endsnippet
snippet unique "Removes Duplicates From vector" !b
sort(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());
endsnippet
snippet gauss "Gaussian Elimination" !b
#define EPS 1E-9
int gauss (vector < vector<double> > a, vector<double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return INT_MAX;
    return 1;
}
endsnippet
snippet lcp "Longest Common Prefix-Suffix" !b
int lcp[MAXN];
void compute_lcp()
{
    lcp[0]=0;
    for(int i=1;i<N;i++)
    {
        if(str[i]==str[lcp[i-1]])
            lcp[i]=lcp[i-1]+1;
        else
        {
            int j=i-1;
            while(j>0&&str[i]!=str[lcp[j]])
                j=lcp[j]-1;
            if(str[i]==str[lcp[j]])
                lcp[i]=lcp[j]+1;
            else
                lcp[i]=0;
        }
    }
}
endsnippet
snippet gentree  "Genrate Random Tree" !b
#define ii pair<int,int>
struct DisjointSet {
    int *root, *rank, n;
    DisjointSet(int sz) {
        root = new int[sz+1];
        rank = new int[sz+1];
        n = sz;
    }
    ~DisjointSet() {
        delete[] root;
        delete[] rank;
    }
    void init() {
        for(int i = 1; i <= n; i++) {
            root[i] = i;
            rank[i] = 0;
        }
    }
    int find(int u) {
        if(u != root[u]) root[u] = find(root[u]);
        return root[u];
    }
    void merge(int u, int v) {
        int pu = find(u);
        int pv = find(v);
        if(rank[pu] > rank[pv]) root[pv] = pu;
        else root[pu] = pv;
        if(rank[pu]==rank[pv]) rank[pv]++;
    }
};
void gentree()
{
    ofstream file;
    file.open("in");
    int n=5;
    DisjointSet ds(n);
    ds.init();
    int q;
    q=5;
    file<<n<<" "<<q<<endl;
    vector<ii> edges;
    while(edges.size()<n-1)
    {
        int a=(rand()%n)+1;
        int b=(rand()%n)+1;
        if(a==b) continue;
        if(ds.find(a)!=ds.find(b))
        {
            if(find(edges.begin(),edges.end(),ii(a,b))==edges.end()&&
                    find(edges.begin(),edges.end(),ii(b,a))==edges.end()    )
            {
                ds.merge(a,b);
                edges.push_back(ii(a,b));
            }
        }
    }
    for(int i=0;i<n;i++)
    {
        file<<rand()%10<<" ";
    }
    file<<endl;
    for(int i=0;i<edges.size();i++)
    {
        file<<edges[i].first<< " "<<edges[i].second<<endl;
    }
    //file<<endl;
    for(int i=0;i<q;i++)
    {
        if(rand()&1)
        {
            file<<"U "<<(rand()%n)+1<<" "<<(rand()%n)+1<<endl;
        }
        else
            file<<"Q "<<(rand()%n)+1<<endl;
    }
    file.close();
}
endsnippet
snippet dset "Union-Find DS" !b
struct disjointset {
    int *root, *rank, n;
    disjointset(int sz) {
        root = new int[sz+1];
        rank = new int[sz+1];
        n = sz;
    }
    ~DisjointSet() {
        delete[] root;
        delete[] rank;
    }
    void init() {
        for(int i = 1; i <= n; i++) {
            root[i] = i;
            rank[i] = 0;
        }
    }
    int find(int u) {
        if(u != root[u]) root[u] = find(root[u]);
        return root[u];
    }
    void merge(int u, int v) {
        int pu = find(u);
        int pv = find(v);
        if(rank[pu] > rank[pv]) root[pv] = pu;
        else root[pu] = pv;
        if(rank[pu]==rank[pv]) rank[pv]++;
    }
};
endsnippet
snippet invcount "inversion count" !b
vector<int> temp(maxn);
long long merge(vector<int> &v,int start,int end)
{
    long long ans=0;
    if(start<end)
    {
        int mid=start+(end-start)/2;
        ans+=merge(v,start,mid);
        ans+=merge(v,mid+1,end);
        int i=start,j=mid+1,k;

        for(k=0;i<=mid&&j<=end;k++)
        {
            if(v[i]<=v[j])
            {
                temp[k]=v[i];
                i++;
            }
            else
            {
                ans+=(mid-i+1);
                temp[k]=v[j],j++;
            }
        }
        for(;i<=mid;i++)
            temp[k++]=v[i];
        for(;j<=end;j++)
            temp[k++]=v[j];

        for(int i=start;i<=end;i++)
            v[i]=temp[i-start];
    }
    return ans;

}
endsnippet
snippet merge "Merge Sort" !b
vector<int> temp(MAXN);
int merge(vector<int> &v,int start,int end)
{
    if(start<end)
    {
        int mid=start+(end-start)/2;
        merge(v,start,mid);
        merge(v,mid+1,end);
        int i=start,j=mid+1,k;

        for(k=0;i<=mid&&j<=end;k++)
        {
            if(v[i]<v[j])
            {
                temp[k]=v[i];
                i++;
            }
            else
                temp[k]=v[j],j++;
        }
        for(;i<=mid;i++)
            temp[k++]=v[i];
        for(;j<=end;j++)
            temp[k++]=v[j];

        for(int i=start;i<=end;i++)
            v[i]=temp[i-start];
    }

}
endsnippet
snippet bs "Differnt Binary Search algos" !b
int leftpos(vector<int> &v,int key)
{
    int r=v.size()-1;
    int l=0;
    while(l<r)
    {
        int m=l+(r-l)/2;
        if(v[m]>=key)
            r=m;
        else
            l=m+1;
    }
    if(v[r]==key)
        return r;
    else
        return -1;
}
int rightpos(vector<int> &v,int key)
{
    int r=v.size()-1;
    int l=0;
    while(l<r)
    {
        int m=r-(r-l)/2;
        if(v[m]<=key)
            l=m;
        else
            r=m-1;
    }
    if(v[l]==key)
        return l;
    else
        return -1;
}
int countequal(vector<int> &v,int key)
{
    int r=rightpos(v,key);
    int l=leftpos(v,key);
    if(r==-1||l==-1) return 0;
    else
        return r-l+1;
}
endsnippet
snippet randdouble "Description" !b
double randdouble()
{
    return double(rand())/double(RAND_MAX);
}
endsnippet
snippet dh "" !b
cout<<"here"<<endl;
endsnippet
snippet db "Debug Macros" !b
#define db(x) cerr << #x << ": " << x << endl;
#define db2(x, y) cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
#define db3(x, y, z) cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
#define db4(a, b, c, d) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
#define db5(a, b, c, d, e) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
#define db6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;
endsnippet
snippet modmul "Eutopian Multiplication" !b
long long modmul(long long n,long long p)
{
    long long ret=1;
    while(p)
    {
        if(p&1){
            ret=ret+n;
            if(ret>=mod) ret%=mod;
        }

        p>>=1;
		n<<=1;
        if(n>=mod)
            n%=mod;
    }
    return ret;
}
endsnippet
snippet isvalid "Description" !b
if(nx>=N||nx<0||ny<0||ny>=M)
endsnippet
snippet bfs  "Bfs" !b
queue<int> q;
q.push(startx);
q.push(starty);
while(!q.empty())
{
	int cx=q.front();q.pop();
	int cy=q.front();q.pop();
	visit[cx][cy]=1;
	for(int k=0;k<4;k++)
	{
		int nx=cx+dx[k];
		int ny=cy+dy[k];

		if(nx>=N||nx<0||ny<0||ny>=M)
			continue;
		if(grid[nx][ny]!='#'&&!visit[nx][ny])
		{
			visit[nx][ny]=1;
			q.push(nx);
			q.push(ny);

		}

	}

}
endsnippet
snippet miller "Miller rabin Primility Test" !b
ll mulmod(ll a, ll b, ll c)
{
    ll x = 0, y = a%c;
    while(b>0)
    {
        if(b&1) x = (x+y)%c;
        y = (y<<1)%c;
        b = b>>1;
    }
    return x;
}
 
ll modulo(ll a, ll b, ll c)
{
    ll x = 1, y = a%c;
    while(b>0)
    {
        if(b&1) x = mulmod(x,y,c);
        y = mulmod(y,y,c);
        b = b>>1;
    }
    return x;
}
 
bool isprime(ll p, int iter)
{
    if(p<2) return false;
    if(p==2) return true;
    if(!(p&1)) return false;
    ll s = p-1, a, temp, mod;
    while(!(s&1)) s = s>>1;
    for(int i=0; i<iter; i++)
    {
        a = rand()%(p-1)+1;
        temp = s;
        mod = modulo(a, temp, p);
        while(temp!=p-1 && mod!=1 && mod!=p-1)
        {
            mod = mulmod(mod, mod, p);
            temp = temp<<1;
        }
        if(mod!=p-1 && !(temp&1)) return false;
    }
    return true;
}
endsnippet
snippet for "Description" !b
for(int i=0;i<N;i++)
{

}
endsnippet
snippet test "Description" !b
int T;scanf("%d",&T);
while(T--)
{

endsnippet
snippet split "split strings on spaces" !b
vector<string> split(std::string const &input) { 
    stringstream buffer(input);
    vector<std::string> ret;
 
    copy(istream_iterator<string>(buffer), 
              std::istream_iterator<std::string>(),
              std::back_inserter(ret));
    return ret;
}
endsnippet
snippet point "point libary" !b
const double PI = acos(-1.0);
const double EPS = 1E-8;

bool zero(double x)
{
	return -EPS < x && x < EPS;
}

int sgn(double x)
{
	return x > EPS ? 1 : (x < -EPS ? -1 : 0);
}

class Point
{
	public:
	double x, y;
	Point() {}
	Point(double x, double y) : x(x), y(y) {}
	void init()
	{
		scanf("%lf%lf", &x, &y);
	}
	void print() const
	{
		printf("Point(%lf %lf)\n", x, y);
	}
	bool operator < (const Point & rhs) const
	{
		return x < rhs.x - EPS || (zero(x - rhs.x) && y < rhs.y - EPS);
		}
	bool operator == (const Point & rhs) const
	{
		return zero(x - rhs.x) && zero(y - rhs.y);
		}
	Point operator - (const Point & rhs) const
	{
		return Point(x - rhs.x, y - rhs.y);
		}
	Point operator + (const Point & rhs) const
	{
		return Point(x + rhs.x, y + rhs.y);
		}
	Point operator * (const double scale) const
	{
		return Point(x * scale, y * scale);
		}
	Point operator / (const double scale) const
	{
		return Point(x / scale, y / scale);
		}
	double operator * (const Point & rhs) const
	{
		return x * rhs.y - rhs.x * y;
		}
	double operator ^ (const Point & rhs) const
	{
		return x * rhs.x + y * rhs.y;
		}
	Point rotate(double angle) const
	{
		Point p(sin(angle), cos(angle));
		return Point((*this) * p, (*this) ^ p);
	}
	double length2() const
	{
		return x * x + y * y;
	}
	double length() const
	{
		return sqrt(this->length2());
		}
	Point trunc(const double scale) const
	{
		return (*this) / this->length() * scale;
		}
	double angle() const
	{
		return atan2(y, x);
		}
	Point perpendicular() const
	{
		return Point(-y, x);
		}
};

class Line
{
	public:
		Point l1, l2;
		Line() {}
		Line(Point l1, Point l2) : l1(l1), l2(l2) {}
		void init()
		{
			l1.init();
			l2.init();
		}
		void print() const
		{
			printf("Line[(%lf %lf)--(%lf %lf)]\n", l1.x, l1.y, l2.x, l2.y);
			}
		bool cross(const Point & p) const
		{
			return zero((p - l2) * (l1 - l2));
		}
		bool cross(const Line &rhs) const
		{
			return !this->parallel(rhs);
			}
		bool parallel(const Line &rhs) const
		{
			return zero((l1 - l2) * (rhs.l1 - rhs.l2));
		}
		Point intersection(const Line &rhs) const
		{
			return l1 + (l2 - l1) * (((l1 - rhs.l1) * (rhs.l1 - rhs.l2)) / ((l1 - l2) * (rhs.l1 - rhs.l2)));
		}
		Point projection(const Point &p) const
		{
			return this->intersection(Line(p, p + (l1 - l2).perpendicular()));
		}
		double distance(const Point &p) const
		{
			return ((p - l1) * (l2 - l1)) / (l1 - l2).length();
		}
		//For finding the perpendicular bisector of a line.
		Line perpendicular_bisector() const
		{
			Point p1=Point( (l1.x+l2.x)/2 , (l1.y+l2.y)/2);
			double m;
			Point p2;
			if( zero(l1.x-l2.x) )
			{
				m=0;
				p2=Point(p1.x+10, p1.y);
			}
			else{
				m=(l1.y-l2.y)/(l1.x-l2.x);
				if( zero(m) )
				{
					p2=Point(p1.x, p1.y+10);
				}
				else
				{
					m=-1/m;
					p2=Point(p1.x+10, p1.y+(10*m));
				}
			}
			return Line(p1, p2);
		}
};

//Finding the area of a polygon, all points must be in order.
double Area(vector<Point> &v)
{
	int n=v.size();

	double area=0;

	for(int i=1; i<n-1; i++)
	{
		Point p1=v[i]-v[0];
		Point p2=v[i+1]-v[0];
		//cout << p1*p2<< endl;
		area+= (p1*p2);
	}
	return abs(area/2);
}
endsnippet
snippet iii "iii" !b
#define iii pair< int,pair<int,int> >
endsnippet
snippet dj "Dijstras" !b
multiset<ii> q;

q.insert(ii(0,N));
vector<int> d(N+2,INT_MAX);
vector<int> visit(N+2,0);
d[N]=0;

while(q.size()>0)
{
	ii c=*q.begin();
	q.erase(q.begin());
	if(c.second==N+1)
		break;
	if(visit[c.second]) continue;
	visit[c.second]=1;

	for(int i=0;i<N+2;i++)
	{
		if(visit[i]) continue;
		if(d[i]>c.first+dist(i,c.second))
		{
			d[i]=c.first+dist(i,c.second);
			q.insert(ii(d[i],i));
		}

	}

}
endsnippet
snippet segtree "Segment Tree" !b
#define MAXN 111111
int tree[4*MAXN];
int lazy[4*MAXN];
vector<int> v;

void build(int node,int start,int end)
{
    if(start>end)
        return ;
    if(start==end)
    {
        tree[node]=v[start-1];
       return ; 
    }

    int mid=(start+end)>>1;
    build(2*node,start,mid);
    build(2*node+1,mid+1,end);

    tree[node]=tree[2*node]+tree[2*node+1];
}
void update(int node,int start,int end,int p,int q,int d)
{
    if(lazy[node]!=0)
    {
        tree[node]+=lazy[node];
        if(start!=end){
            lazy[2*node]+=(lazy[node]);
            lazy[2*node+1]+=lazy[node];
        }
        lazy[node]=0;
    }
    if(start>end||start>q||end<p)
        return ;
    if(start>=p&&q>=end)
    {
        tree[node]+=d;
        if(start!=end){
            lazy[2*node]+=(d);
            lazy[2*node+1]+=d;
        }
        return ;

    }

    int mid=(start+end)>>1;
    update(2*node,start,mid,p,q,d);
    update(2*node+1,mid+1,end,p,q,d);

    tree[node]=tree[2*node]+tree[2*node+1];
}
int query(int node,int start,int end,int p,int q)
{
    if(start>end||start>q||end<p)
        return 0;
    if(lazy[node]!=0)
    {
        tree[node]+=lazy[node];
        if(start!=end){
            lazy[2*node]+=(lazy[node]);
            lazy[2*node+1]+=lazy[node];
        }
        lazy[node]=0;
    }
    if(start>=p&&q>=end)
    {
        return tree[node];
    }
    int mid=(start+end)>>1;

    return query(2*node,start,mid,p,q)+
        query(2*node+1,mid+1,end,p,q);

}
endsnippet
snippet sieveip "sieve is prime " !b
bool isprime(int n)
{
	if(n<2) return 0;
	if(n==2) return 1;
	if(!(n&1)) return 0;
	else
		return !mark[n>>1];
}
endsnippet
snippet sieve "sieve" !b
vector<bool> mark(MAXN>>1);
vector<int> primes;
primes.push_back(2);
int i;
for(i=3;i*i<MAXN;i+=2)
{
	if(!mark[i>>1])
	{
		for(int j=i*i;j<MAXN;j+=2*i)
		{
			mark[j>>1]=1;	
		}
		primes.push_back(i);
	}

}
for(;i<MAXN;i+=2)
{
	if(!mark[i>>1])
	{
		primes.push_back(i);
	}
}
endsnippet
snippet factorize "factorize" !b
vector<int> factorize(int x)
{
    vector<int> ret;
    for(int i=0;i<primes.size();i++)
    {
        while(x%primes[i]==0)
        {
            x/=primes[i];
            ret.push_back(primes[i]);
        }
    }
    return ret;
}
endsnippet
snippet tobinary "tobianary" !b
string tobinary(int x)
{
    string ret;
    while(x!=0)
    {
        ret=(char)(x%2+'0')+ret;
        x>>=1;
    }
    return ret;
}
endsnippet
snippet knightdir "knights direction arrays" !b
int dx[]={1,2,1,2,-1,-2,-1,-2};
int dy[]={2,1,-2,-1,2,1,-2,-1};
endsnippet
snippet bit "binary indexed tree" !b
int tree[MAXN];
void update(int index,int value)
{
	assert(index!=0);
	while(index<MAXN)
	{
		tree[index]+=value;
		index+=(index&-index);
	}
}
int sum(int index)
{
	int s=0;
	while(index>0)
	{
		s+=tree[index];
		index-=(index&-index);
	}
	return s;
}
endsnippet
snippet gentest "genernating testcases function" !b
void gentests()
{
    ofstream file;
    file.open("in");
    int n=10000;
    file<<n<<endl;
    while(n--)
    {
        file<<(rand()%10)+1<<" " ;
    }
	file.close();
    file<<endl;
}
endsnippet
snippet pll "description" !b
printf("%lld\n",$1);
endsnippet
snippet p "Description" !b
printf("%d\n",$1);
endsnippet
snippet iarray "input an array" !b
for(int i=0;i<N;i++)
{
	s(v[i]);
}
endsnippet
snippet igrid "input a Matrix" !b
scanf("%d %d",&N,&M);
for(int i=0;i<N;i++)
{
	scanf("%s",temp);
	for(int j=0;j<M;j++)
	{
		grid[i][j]=temp[j];
	}
}
endsnippet
snippet dir2 "directions2 " !b
int dx2[]={1,-1,0,0,1,-1,1,-1};
int dy2[]={0,0,-1,1,-1,1,1,-1};
endsnippet
snippet dir "directions " !b
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
endsnippet
snippet toint "toint" !b
int toint(string str)
{
    istringstream is(str);
    int x;
    is>>x;
    return x;
}
endsnippet
snippet tostring "tostring function c++" !b
string tostring(int x)
{
    ostringstream os;
    os<<x;
    return os.str();
}
endsnippet
snippet ii "define pair" !b
#define ii pair<int,int>
endsnippet
snippet ll "define ll" !b
#define ll long long
endsnippet
snippet mod "define mod" !b
#define mod 1000000007
endsnippet
snippet maxn "define max" !b
#define MAXN 1111111
endsnippet
snippet modpow "modpow function" !b
long long modpow(long long n,long long p)
{
    long long ret=1;
    while(p)
    {
        if(p&1){
            ret=ret*n;
            if(ret>=mod) ret%=mod;
        }

        p=p/2;
        n*=n;
        if(n>=mod)
            n%=mod;
    }
    return ret;
}
endsnippet
snippet fastio "fast i/o class" !b
static struct io {
        char tmp[1 << 10];
 
        // fast input routines
        char cur;
 
//#define nextChar() (cur = getc_unlocked(stdin))
//#define peekChar() (cur)
        inline char nextChar() { return cur = getc_unlocked(stdin); }
        inline char peekChar() { return cur; }
 
        inline operator bool() { return peekChar(); }
        inline static bool isBlank(char c) { return (c < '-' && c); }
        inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }
 
        inline IO& operator >> (char & c) { c = nextChar(); return *this; }
 
        inline IO& operator >> (char * buf) {
                if (skipBlanks()) {
                        if (peekChar()) {
                                *(buf++) = peekChar();
                                while (!isBlank(nextChar())) *(buf++) = peekChar();
                        } *(buf++) = 0; } return *this; }
 
        inline IO& operator >> (string & s) {
                if (skipBlanks()) {     s.clear(); s += peekChar();
                        while (!isBlank(nextChar())) s += peekChar(); }
                return *this; }
 
        inline IO& operator >> (double & d) { if ((*this) >> tmp) sscanf(tmp, "%lf", &d); return *this; }
 
#define defineInFor(intType) \
        inline IO& operator >>(intType & n) { \
                if (skipBlanks()) { \
                        int sign = +1; \
                        if (peekChar() == '-') { \
                                sign = -1; \
                                n = nextChar() - '0'; \
                        } else \
                                n = peekChar() - '0'; \
                        while (!isBlank(nextChar())) { \
                                n += n + (n << 3) + peekChar() - 48; \
                        } \
                        n *= sign; \
                } \
                return *this; \
        }
 
defineInFor(int)
defineInFor(unsigned int)
defineInFor(long long)
 
        // fast output routines
 
//#define putChar(c) putc_unlocked((c), stdout)
        inline void putChar(char c) { putc_unlocked(c, stdout); }
        inline IO& operator << (char c) { putChar(c); return *this; }
        inline IO& operator << (const char * s) { while (*s) putChar(*s++); return *this; }
 
        inline IO& operator << (const string & s) { for (int i = 0; i < (int)s.size(); ++i) putChar(s[i]); return *this; }
 
        char * toString(double d) { sprintf(tmp, "%lf%c", d, '\0'); return tmp; }
        inline IO& operator << (double d) { return (*this) << toString(d); }
 
 
#define defineOutFor(intType) \
        inline char * toString(intType n) { \
                char * p = (tmp + 30); \
                if (n) { \
                        bool isNeg = 0; \
                        if (n < 0) isNeg = 1, n = -n; \
                        while (n) \
                                *--p = (n % 10) + '0', n /= 10; \
                        if (isNeg) *--p = '-'; \
                } else *--p = '0'; \
                return p; \
        } \
        inline IO& operator << (intType n) { return (*this) << toString(n); }
 
defineOutFor(int)
defineOutFor(long long)
 
#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;
endsnippet
snippet bigint "bigint libary" !b
const int base = 1000000000;
const int base_digits = 9;

struct bigint {
    vector<int> a;
    int sign;

    bigint() :
        sign(1) {
        }

    bigint(long long v) {
        *this = v;
    }

    bigint(const string &s) {
        read(s);
    }

    void operator=(const bigint &v) {
        sign = v.sign;
        a = v.a;
    }

    void operator=(long long v) {
        sign = 1;
        if (v < 0)
            sign = -1, v = -v;
        for (; v > 0; v = v / base)
            a.push_back(v % base);
    }

    bigint operator+(const bigint &v) const {
        if (sign == v.sign) {
            bigint res = v;

            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {
                if (i == (int) res.a.size())
                    res.a.push_back(0);
                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);
                carry = res.a[i] >= base;
                if (carry)
                    res.a[i] -= base;
            }
            return res;
        }
        return *this - (-v);
    }

    bigint operator-(const bigint &v) const {
        if (sign == v.sign) {
            if (abs() >= v.abs()) {
                bigint res = *this;
                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {
                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);
                    carry = res.a[i] < 0;
                    if (carry)
                        res.a[i] += base;
                }
                res.trim();
                return res;
            }
            return -(v - *this);
        }
        return *this + (-v);
    }

    void operator*=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
            if (i == (int) a.size())
                a.push_back(0);
            long long cur = a[i] * (long long) v + carry;
            carry = (int) (cur / base);
            a[i] = (int) (cur % base);
            //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
        }
        trim();
    }

    bigint operator*(int v) const {
        bigint res = *this;
        res *= v;
        return res;
    }

    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {
        int norm = base / (b1.a.back() + 1);
        bigint a = a1.abs() * norm;
        bigint b = b1.abs() * norm;
        bigint q, r;
        q.a.resize(a.a.size());

        for (int i = a.a.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.a[i];
            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];
            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
            int d = ((long long) base * s1 + s2) / b.a.back();
            r -= b * d;
            while (r < 0)
                r += b, --d;
            q.a[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm);
    }

    bigint operator/(const bigint &v) const {
        return divmod(*this, v).first;
    }

    bigint operator%(const bigint &v) const {
        return divmod(*this, v).second;
    }

    void operator/=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = a[i] + rem * (long long) base;
            a[i] = (int) (cur / v);
            rem = (int) (cur % v);
        }
        trim();
    }

    bigint operator/(int v) const {
        bigint res = *this;
        res /= v;
        return res;
    }

    int operator%(int v) const {
        if (v < 0)
            v = -v;
        int m = 0;
        for (int i = a.size() - 1; i >= 0; --i)
            m = (a[i] + m * (long long) base) % v;
        return m * sign;
    }

    void operator+=(const bigint &v) {
        *this = *this + v;
    }
    void operator-=(const bigint &v) {
        *this = *this - v;
    }
    void operator*=(const bigint &v) {
        *this = *this * v;
    }
    void operator/=(const bigint &v) {
        *this = *this / v;
    }

    bool operator<(const bigint &v) const {
        if (sign != v.sign)
            return sign < v.sign;
        if (a.size() != v.a.size())
            return a.size() * sign < v.a.size() * v.sign;
        for (int i = a.size() - 1; i >= 0; i--)
            if (a[i] != v.a[i])
                return a[i] * sign < v.a[i] * sign;
        return false;
    }

    bool operator>(const bigint &v) const {
        return v < *this;
    }
    bool operator<=(const bigint &v) const {
        return !(v < *this);
    }
    bool operator>=(const bigint &v) const {
        return !(*this < v);
    }
    bool operator==(const bigint &v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const bigint &v) const {
        return *this < v || v < *this;
    }

    void trim() {
        while (!a.empty() && !a.back())
            a.pop_back();
        if (a.empty())
            sign = 1;
    }

    bool isZero() const {
        return a.empty() || (a.size() == 1 && !a[0]);
    }

    bigint operator-() const {
        bigint res = *this;
        res.sign = -sign;
        return res;
    }

    bigint abs() const {
        bigint res = *this;
        res.sign *= res.sign;
        return res;
    }

    long long longValue() const {
        long long res = 0;
        for (int i = a.size() - 1; i >= 0; i--)
            res = res * base + a[i];
        return res * sign;
    }

    friend bigint gcd(const bigint &a, const bigint &b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend bigint lcm(const bigint &a, const bigint &b) {
        return a / gcd(a, b) * b;
    }

    void read(const string &s) {
        sign = 1;
        a.clear();
        int pos = 0;
        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-')
                sign = -sign;
            ++pos;
        }
        for (int i = s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for (int j = max(pos, i - base_digits + 1); j <= i; j++)
                x = x * 10 + s[j] - '0';
            a.push_back(x);
        }
        trim();
    }

    int length(){
        int l=0,back=a.back();
        while(back){l++;back/=10;}
        l+=((a.size()-1)*base_digits);
        return l;
    }

    friend istream& operator>>(istream &stream, bigint &v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream &stream, const bigint &v) {
        if (v.sign == -1)
            stream << '-';
        stream << (v.a.empty() ? 0 : v.a.back());
        for (int i = (int) v.a.size() - 2; i >= 0; --i)
            stream << setw(base_digits) << setfill('0') << v.a[i];
        return stream;
    }

    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int) p.size(); i++)
            p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back(int(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int) cur);
        while (!res.empty() && !res.back())
            res.pop_back();
        return res;
    }

    typedef vector<long long> vll;

    static vll karatsubaMultiply(const vll &a, const vll &b) {
        int n = a.size();
        vll res(n + n);
        if (n <= 32) {
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    res[i + j] += a[i] * b[j];
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        for (int i = 0; i < k; i++)
            a2[i] += a1[i];
        for (int i = 0; i < k; i++)
            b2[i] += b1[i];

        vll r = karatsubaMultiply(a2, b2);
        for (int i = 0; i < (int) a1b1.size(); i++)
            r[i] -= a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            r[i] -= a2b2[i];

        for (int i = 0; i < (int) r.size(); i++)
            res[i + k] += r[i];
        for (int i = 0; i < (int) a1b1.size(); i++)
            res[i] += a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            res[i + n] += a2b2[i];
        return res;
    }

    bigint operator*(const bigint &v) const {
        vector<int> a6 = convert_base(this->a, base_digits, 6);
        vector<int> b6 = convert_base(v.a, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while (a.size() < b.size())
            a.push_back(0);
        while (b.size() < a.size())
            b.push_back(0);
        while (a.size() & (a.size() - 1))
            a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        bigint res;
        res.sign = sign * v.sign;
        for (int i = 0, carry = 0; i < (int) c.size(); i++) {
            long long cur = c[i] + carry;
            res.a.push_back((int) (cur % 1000000));
            carry = (int) (cur / 1000000);
        }
        res.a = convert_base(res.a, 6, base_digits);
        res.trim();
        return res;
    }
};
endsnippet
